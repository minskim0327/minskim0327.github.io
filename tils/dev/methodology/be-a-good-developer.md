# 좋은 개발자 되기

![](https://media.vlpt.us/post-images/zeros0623/4738da90-fb29-11e9-a1e9-51b195b2925d/developer.jpg)

## Overview

'좋은 개발자'는 너무도 모호하다. TDD 를 제대로 실무에 적용할 줄 아는 개발자일 수도 있고,
순식간에 엄청난 양의 코드를 만들어내는 퍼포먼스를 가진 개발자 일 수도 있고,
뼛속까지 [소프트웨어 장인정신](https://en.wikipedia.org/wiki/Software_craftsmanship) 을 장착한 개발자일 수도 있다.

어느 것 하나 틀린 것도 아니고, 어느 것 하나가 옳다고 말할 수도 없다. 여러 유형의 개발자들을 살펴보면서 그 사람들의 장점을 본받아
나만의 '좋은 개발자' 를 만들어가면 그게 최선이지 않을까 싶다.

## 나만의 기준

내가 2020년 말 세웠던 좋은 개발자의 기준은 다음 7가지다.

* 생산성이 높다
* 안정적으로 주어진 문제를 해결한다
* 협업을 잘한다
* 제너럴, 도메인 지식이 풍부하다
* 안정적인 코드를 짠다
* 깨끗한 코드를 작성한다
* 소프트웨어 설계를 잘한다

기준을 세웠으니 달성하는 게 마땅할 것이다. 하지만 어떻게?

### 생산성이 높으려면

생산성이 높다는 것은 단위 시간당 처리해내는 업무의 수가 많다는 것이다.

그렇다면 먼저, 시간 관리가 잘 되어야 한다.
나는 [뽀모도로 기법](https://ko.wikipedia.org/wiki/%ED%8F%AC%EB%AA%A8%EB%8F%84%EB%A1%9C_%EA%B8%B0%EB%B2%95)
을 개인적으로 활용하고 익숙해지려 노력하고 있다. 25분 일하고, 5분은 앞 25분에 대해 회고하는 식이다.
그러다가 long term break 를 만나면, 쉴 겸 장르 불문한 독서를 한다.

두 번째로, 내가 처리한 업무가 쓸모 있어야 한다. 그러기 위해서 무슨 일을 하든 먼저 Why 에 대해 답할 줄 알아야 한다.
이 일을 왜 하는지 알게 되면 무엇을 해야 하는지 보이고, 뭘 해야 하는지 알면 어떻게 해야 그것을 확보할 수 있는지 고민할 수 있게 된다.
이 Why - How - What 사이클에서 벗어나, 역순으로 하거나 엉뚱한 순서로 일을 처리하게 되면 내가 열심히 했던 일이 휴지조각으로 변하거나
대폭 수정해야 하는 일이 비일비재하게 일어나곤 한다.

내가 시간 관리도 잘하고, 항상 중요한 일만을 처리할 수 있다면 나머진 본인의 역량이다.
한 마디로 코딩을 잘해야 한다는 말이다. 여기에는 절대적인 시간이 필요하므로 많이, 그리고 깊이 파고들수록 생산성이 올라갈 것을 기대해야 한다.

개발에 있어서 개인적으로, **코드에 대한 모델링**에 익숙해질수록 생산성이 올라가는 것을 경험한 적이 있다. 코드에 대한 모델링이라는 건
따로 컴파일을 돌리지 않아도 머릿속에서 프로그램이 자유자재로 돌아가는 것을 의미한다. 함꼐 일했던 훌륭한 개발자 분들은 가끔,
버그가 발생했을 때 '아 뭐가 문제인지 알겠어요' 라고 외치며 프로그램을 돌려보지도 않고 곧바로 원인을 찾아내곤 했다.
나는 그 모습을 지켜보며 저들은 나와 무엇이 다를까? 를 고민하다가 알아낸 것이 바로 이 모델링이다. 

### 안정적으로 주어진 문제를 해결하려면

이것은 어려운 질문이다. 문제 해결 능력도 있어야 하고, 그 문제를 해결함에 있어 여러가지 변수들을 미리 예측하여 대비하는 능력도 갖추어야 한다.
여기에 디테일을 중요하게 생각하는 꼼꼼함은 덤이다.

문제 해결 능력이라는 것은 코드 레벨과 팀내 의사 결정 레벨 등 여러가지 레벨에서 종합적으로 요구되는 능력이니 만큼
빠른 판단력과 경험이 있어야 한다. 경험이 쌓이면 후에 비슷한 일이 생겼을 때 발생할 문제에 대해 일부 예측도 가능해진다.

즉, 이 질문은 어떻게 해야 성장에 도움이 되는 경험을 빠른 시간안에 많이 할 수 있는지와 꼼꼼하에 일을 처리할 수 있는지로 바뀐다.
빠른 시간안에 많은 경험을 하려면 나를 항상 불편한 영역(Uncomfortable zone) 으로 밀어넣어야 한다. 반복되는 일이 있다면
자동화하고 항상 새로운 것을 갈구해야 한다.

나는 태생적으로 꼼꼼하지 않은 사람이라, 꼼꼼해지기 위한 노력을 부던히도 했다. 내가 작성한 코드를 셀프 리뷰하거나,
로컬에서 테스트를 끝내는 것이 아닌 배포까지 해서 확인하는 등. 뽀모도로와 결합하면, 휴식시간에 내가 지금 하고 있는 일에 대해서
고민하다보면 놓쳤던 부분이 떠오르기도 한다.

### 협업을 잘하려면

협업을 잘하려면 커뮤니케이션 능력이 바탕에 깔려 있어야 한다. 상대방의 감정을 해치지 않으면서 나의 의사를 확실하게 전달하고
논의를 할 때 비효율을 항상 경계해야한다.

비효율을 경계하는 것에 대해 좋은 예로 유비쿼터스 랭귀지가 있다. 도메인 전문가와 개발자 사이에 공통 도메인 언어를 정의하여
서로 간에 단어 선택이 엇갈리고 이에 대해 부연설명하는 비효율을 애초에 차단하는 것이다.

실제로, storybook 을 내부 배포함으로써 디자이너와의 커뮤니케이션을 개선한 경험이 있다.

### 제너럴, 도메인 지식이 풍부하려면

일단 제너럴 지식을 늘리기 위해서는 적극적으로 proof of concept 을 위한 프로젝트를 여러개 해봐야 한다.
업무에서 mongoDB 를 썼고, mongoDB 에 대해 배운 점들을 정리했다고 다가 아니라 MySQL 이나 PostgreSQL 에 대해
찾아보면서 프로젝트를 만들어야 한다는 것이다. 하지만 이것은 업무에 치이다 보면 정말 하기 힘들일이 된다.
그래서 내가 택하는 방법은 다음 3가지 중에 하나를 택해서 시간 분배를 하고 취사학습을 한다.

* 1시간만 조사하여 개념을 익힌다.
* 3~4 시간을 투자하여 튜토리얼을 따라한다.
* 1일을 투자하여 샘플 코드를 만든다.

도메인 지식을 늘리려면 도메인 전문가와 긴밀히 협력하는 수밖에 없다. 다만, 도메인 지식이 개발과 관련된 영역이 아니라고 해서
거부감을 표하지 말고 적극적으로 도메인 지식을 얻기 위해 노력해야 한다.

### 안정적인 코드를 짜려면

안정적인 코드라는 것은 결국 버그가 없는 코드이다. 사실 버그를 완벽히 없애는 것은 불가능하다.
상정한 모든 케이스에 대해 테스트를 해봐도 예상치 못한 버그가 튀어나오기 때문이다. 우리의 목표는 상정한 모든 케이스에서라도
버그가 없게끔하는 것이다.

가장 좋은 방법은 TDD를 하는 것이다. TDD를 하게 되면 모듈을 테스트하기 쉽게 짤 수 밖에 없게 되고,
의존성이 정리되면 코드가 간단해지므로 KISS 원칙을 지키기 쉬워진다.
개인적으로 좋아하는 비야네의 어록 중에선 이런 말이 있다: '논리가 간단해야 버그가 숨어들지 못한다'.

### 깨끗한 코드를 작성하려면

꺠끗한 코드의 정의는 개발자의 수 만큼이나 다양하다. 하지만 내가 여기서 정의하는 깨끗한 코드
엉클밥의 [Clean code](https://en.wikipedia.org/wiki/Robert_C._Martin) 를 원칙으로 한다.

이 책은 많이 읽고 많이 따라해보고 많이 경험하는 수 밖에 없다. 나는 이 책을 학부생 시절부터 5번이나 읽었지만
매번 볼때마다 새로운 내용이 눈에 들어온다. 예전에는 '뭐야 당연한 내용이잖아' 했던 내용이 '아 이게 그 뜻이었어? 우와...' 하는 순간이
찾아오더란 말이다. 엉클밥은 아득한 경지에 있고 나는 레벨업 할 때마다 차근 차근 내 높이에서 보이는 것들을 얻을 수 있었을 뿐이다.
 
### 소프트웨어 설계를 잘하려면

좋은 소프트웨어 설계는 의사결정을 최대한 미룰 수 있는 설계이다. 최대한 많은 정보를 얻을 후에 내린 결정이 그렇지 않은 결정보다
항상 더 낫기 때문이다.

이걸 잘하려면 학부 시절 때 배우던 추상화를 잘해야 한다. 어떤 게 도메인이고 어떤 것이 아닌지 구분하여 도메인이 아닌 것들은
전부 추상화 시켜 의존성 역전을 시킬 수 있어야 한다. 하지만 도메인과 도메인이 아닌 것을 구분하는 것은 힘들다.
이 때 제너럴한 지식이 많다면 좀 더 도움을 받을 수 있다.
