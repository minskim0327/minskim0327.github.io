# KISS

Keep It Simple and Stupid, Keep It Small and Stupid, Keep It Short and Simple.

## Overview

이 원칙을 지켜야 하는 이유는 간단하다. 단순할 수록 이해하기 쉽고, 이해하기 쉬울수록 버그가 발생할 가능성이 줄어들기 때문이다.
이는 곧 유지보수 비용을 줄이고 생산성을 향상시킨다.

그러나 단순히 '작고 멍청하고 짧고 단순하게' 는 '알잘딱센' 만큼이나 추상적이다. 좀 더 구체적으로 고민해볼 순 없을까?

## How can we Keep It Simple and Stupid?

단순하고 멍청하게 유지하라니. 도대체 어떻게?

이 둘은 결국 서로 이어지긴 하지만, 먼저 **단순함**부터 파고들어가 보자.

코드를 보는 사람은 인간이고, 생리학적으로 인간은 병렬적으로 생각하는 능력이 취약하다.
프로그래머도 결국은 인간이니, 코드를 파악하거나 변경하려 할 때 한 번에 신경써야할 점들이 많아질수록 프로그래머는 복잡하다고 느낀다.
그렇다면 반대로 한 번에 신경써야할 점들이 적어질수록 인간은 단순하다고 느낄까? 여기에는 제한사항이 있다. 바로 가독성과 크기의 제한이다.
KISS 의 변형인 Short, Small 은 바로 여기에 기인한다. 신경 쓸 것도 없으면서 잘 읽히고, 크기도 작아야 우리 인간들은 단순하다고 느낀다.

### 잘 읽히고, 크기도 작아야

네이밍을 해괴망측하게 하지 않는다는 가정 하에 잘 읽히고 크기도 작으려면 결국 추상화를 잘해야 한다. 소프트웨어가 풀고자 하는 문제를
단순화 시키고, 추상화 레벨에 신경을 쓰며 함수들을 작성해야 한다. 그래야 크기도 작으면서 읽기도 쉬운 코드들이 나온다.

이는 마치 초등학생이 그린 그림지도는 위성 사진보다 이해하기 쉬운 것과 같다. 위성 사진에서 보이는 모든 정보들을 한 파일에서 표현하려고 하면
양도 너무 많아지고 잘 읽히지도 않는다. 바깥에서 보았을 때, 소프트웨어는 그림지도 처럼 추상화되어 보여야 한다.

### 신경 쓸 점들을 줄이려면

신경 쓸 점들을 줄이려면 의존성을 최대한 단순하게 가져가야 한다. 이는 곧 객체지향에서의 SOLID, 더 크게는 Clean Architecture
로 귀결되는데, 모듈 간 의존성이 얽히고 섥히는 순간부터 우리는 점점 변경시마다 신경써야 할 점들이 많아진다.

가장 단순하고 극적인 예로는 수정 가능한 전역 변수가 있다. 여러 모듈에서 이 변수를 사용한다면 많은 모듈들은 이 변수에 의존하는 것이고
이 변수를 컨트롤하는 또 다른 모듈을 추가하려 할 때 이 변수에 의존하고 있는 모듈의 수만큼 신경써야 할 점이 많아지게 될 것이다.

당연히 의존 대상은 전역 변수뿐만 아니라 어떤 모듈이 될 수도 있다. 
그러나 모듈이 서로를 알면 알수록 점점 유식해지고, 이들이 유식해질 수록 신경써야 할 점들이 늘어나는 것이다. 그만큼 주변 모듈들의
변경에 예민해지고 관여를 하게되기 때문이다. 
여기서 멍청함과 단순함이 이어지는 연결점이 드러난다. 유식해진다는 것은 즉, **멍청해지지 않는다는 것**을 의미하기 때문이다.
의존성을 최대한 줄이고 또 줄여야 우리는 모듈들이 멍청해지도록 만들 수 있다. 주변 상황이 바뀌어도 눈치 못채는 멍청이 모듈 말이다.

## Conclusion

사실 나는 KISS 원칙을 너무 확대해석한 것일지도 모른다. 하지만 그렇다 한들 어떠한가. 나는 더 나은 코드를 위해서라면 더욱 엄격한 원칙도
지킬 의향이 있다.

결론적으로, 우리는 다음을 매 순간 깊게 고민하고 처절하게 사수해내야 한다.

* 모듈 레벨에서는 계층을 분리하여 의존성을 최대한 줄여야 한다.
* 클래스 레벨에서는 클래스의 응집도를 높이고, 단 한 가지 책임만을 지도록 한다.
* 함수 레벨에서는 추상화 레벨을 맞추어 함수들을 추출해내고 각 함수가 단 한가지 일만을 잘하도록 해야 한다.
* 코드 한줄 한줄 잘 읽히게끔 좋은 이름을 선택해야 한다.

그래야 KISS 원칙을 따른다고 볼 수 있는 것이다.
