# YAGNI

You ain't gonna need it

## Overview

이 원칙을 지켜야 하는 이유 역시 [KISS](./kiss.md) 와 마찬가지로 간단하다. 일어나지 않을 미래를 예상해서 미리 작성하는 코드는
코드 복잡도를 증가시키고 이는 곧 생산성 저하를 유발하며, 정말 필요한 시점이 오더라도 오히려 작성했던 코드를 뜯어고치는 일이 추가로 늘어날 수 있다는 것이다.

즉, YAGNI는 한번에 미래까지 예상해서 만들기 보단, 지속적인 리펙토링에 의존하라는 원칙이다.

### 우리에게 허용된 미래예측의 범위는 얼마만큼인가

인터넷 어디를 뒤져봐도 이 원칙이 무엇인가에 대한 설명을 차고 넘치지만, 그 어디에도 얼마만큼 미래를 예측해야 하는지에
대한 이야기는 나오지 않는다. 1:1 채팅방을 만들면서 그룹 채팅방이 도입될 것을 고려하며 설계하고 구현하는 것이 정말 해서는 안될 일일까?
딱 1:1만 가능하도록 만들어야 할까?

조금 구체적인 예시를 찾아보려 검색해봤는데 다음과 같은 글을 발견했다.

"MySQL을 사용하고 있는 상황에서 MongoDB, PostgreSQL 등등을 쓸 것을 대비해 비즈니스 계층을 도입하여 추상화하는 것은
YAGNI 원칙에 위배됩니다..." 

내 개인적인 견해는 이와 다르고, 덕분에 이는 YAGNI 원칙을 한 번 정리해볼 수 있는 계기를 마련해주었다.

우선 '비즈니스 계층' 이라는 말이 무엇인지는 모르겠지만 어떤 의존성을 역전시킨 계층이라고 생각된다.
의존성을 역전시켰다는 의미는 컴파일 의존성과 런타임 의존성을 역전시켰다는 것이고 이는 곧 유연한 설계와 재사용 가능한 코드를 확보했음을 의미한다.
즉, 소스 코드는 추상적인 Repository에 의존하지만 런타임에는 MySQL이라는 구체적인 모듈에 의존하게 된다는 것이다.

두 번째는 예상하는 상황이 적중했을 경우 드는 비용이 과연 예측하지 않았을 때보다 충분히 적다고 할 수 있는가? 하는 부분이다.
계층이 존재하지 않는 상황에서 MySQL을 Mongo 로 교체하는 작업은 상상도 하기 싫을만큼 끔찍하다. 사실 이 작업은 계층이 있어도 끔찍한데 없으면
여부가 있겠느냐는 말이다.

## Conclusion

미래의 기능을 미리 예상해서 구현하는 것은 확실히 비효율적이다. 하지만 우리는 구현하지 않아도 된다고 해서 리펙토링에도 관심을 꺼야 하는 것은 아니다.
리펙토링하면서 기능을 변경하지 않았다는 확신을 e2e 테스트나 QA 에 의존하는 것은 너무나 비효율 적이다. 리펙토링에 신경쓴다면
당연히 테스트 코드에도 신경을 써야하고, 테스트 코드를 신경 쓴다면 반드시 컴파일 의존성과 런타임 의존성을 살펴야 한다.

또, 1:1 채팅방을 만들면서 그룹 채팅방이 도입될 것을 고려하냐 마느냐의 문제는 좀 특수하다고 생각한다.
사실 1:1 채팅방은 그룹 채팅방에 포함되는 개념이다. 그룹 사이즈가 2인 경우에 해당되기 때문이다. 접근 방식에 따라
여러 문제들을 한꺼번에 해결할 수 있다면, 또 그리고 그 접근 방식이 복잡하지 않고 충분히 합리적이라면
그런 예측 정도는 해도 된다는 것이 내 개인적인 의견이다.

하지만 그런 극소수 경우가 아니고, 기획에도 포함되어 있지 않다면 지양하는 것이 좋다고 생각한다.
