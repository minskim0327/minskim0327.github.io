# System

![](https://t1.daumcdn.net/cfile/tistory/2316474058A112F31D)

시스템은 여러 객체들이 서로 협력하여 기능을 달성하는 일종의 공동체다. 그러나 이러한 객체들은 어느 순간 팍하고 튀어나오는 것이 아니라
일일이 생성하고 연결을 해주어야 한다. 이 때 반드시 **시스템은 객체를 제작하고 의존성을 연결하는 준비과정과 런타임 로직을 분리해야 한다**.
이 두 로직이 서로 뒤엉키게 되면 테스트하기가 불편해지고 객체의 생성과 사용 2가지 책임이 생기므로 SRP가 깨질 염려가 생긴다.

테스트하기가 불편해진다는 것은 생성해야 하는 객체가 무거운 객체일 경우 test double을 만들려면 많은(혹은 더러운) 준비가 필요해진다는 것이
그 첫번째 이유이며, 객체의 생성여부와 관련한 테스트가 추가되어야 한다는 것이 그 두 번째 이유이다.

이와 같이 시스템을 준비하는 부분을 Main Partition 이라고 부르고, 런타임 로직을 관장하는 부분을 App Partition 이라고 부른다. 
즉, Main Partition은 의존성을 제작하고 제공하며, App Partition은 이미 모든 의존성이 준비되었다고 가정하고 로직에 집중한다.

## App partition 이 의존성의 생성 시점을 결정해야하는 경우

사용자의 입력에 의해 다른 의존성을 받아야 하는 등 여러가지 이유로 인해 App partition이 의존하는 객체의 생성 시점을 결정해야
하는 경우가 존재한다. 이 때는 추상 팩토리 메소드 패턴을 사용한다. Main partiion 에서는 추상 팩토리 인터페이스를 구현하고,
App partition 에서는 객체가 필요해지는 시점에 의존성을 생성하여 해당 객체의 인터페이스만 알고 실제 구현부에는 관심이 없도록 하는 것이다.

## Dependency Injection

App partition 과 Main partiion 을 분리하는 가장 강력한 매커니즘 중 하나는 DI(Dependency Injection)다.
이를 사용하면 lazy-loading 을 하든, singleton 을 사용하든, 매번 생성하여 로딩하든 컨테이너가 알아서 설정에 따라 의존성을 관리해주기
때문에 보다 명확한 분리가 가능해진다.

## Cross-cutting concerns

Cross-cutting concerns, 횡단 관심사는 말 그대로 시스템을 가로지르는 관심사다. 예시로 다음과 같은 것들이 있다.

* 로깅
* 영속성 관리 (Persistency)
* 최적화
* 보안
* 기타 등등

횡단 관심사는 AOP(Aspect Oriented Programming, 관점 지향 프로그래밍)이 나오게 된 배경이기도 하다. AOP 에서는 위 관심사
마저도 모듈로 분리하고자 한다. 가장 많이 사용되는 패턴은 Decorator 패턴이다.
모듈로 따로 구분하여 어노테이션을 통해 해당 모듈을 사용하게 만들어 주는 것이다. 

## Conclusion

위와 같이 시스템을 꺠끗하게 유지하지 않으면 기민성이 떨어지고, 이는 TDD가 제공하는 장점을 부숴버리는 결과를 낳아 도미노처럼
연쇄반응이 일어나 제품의 품질까지 떨어뜨리게 된다.

그러나 단순성이 먼저다. **시스템은 그 기능을 달성하기 위한 가장 단순한 방법을 택해야 한다**. 시스템을 설계할때는 항상 이 문장을
염두에 두어야 한다.
