# 디미터 규칙 (The Law of Demeter)

> 이런 식으로 생각하자. 자기 소유의 장난감, 자기가 만든 장난감, 그리고 누군가 자기에게 준 장난감하고만 놀 수 있다. 하지만 절대 장난감의 장난감과 놀면 안 된다.

## 디미터 법칙을 지켜야 하는 이유

디미터 법칙을 따르게 되면 느슨히 결합된 클래스가 생성되고, 그들의 구현 비밀은 캡슐화로 감춰진다.
이런 클래스들이라면 아주 부담이 적어서 어떤 클래스의 의미를 알고자 할 때, 다른 여러 클래스의 상세한 내용까지는 알지 않아도 된다.

반면 디미터 법칙을 위반하는 경우 메시지 체인이라는 악취가 난다. 열차 전복, 기차 충돌(train wreck) 이라고 불리는 전형적인 코드는 다음과 같다.

```java
object.getChild().getContent().getItem().getTitle();
```

이처럼 프로그램 순회의 경로가 길어질수록 프로그램은 더 불안정해진다. 그 이유는 객체 구조(연결)는 언제든지 변경될 수 있기 때문이다.

즉, 우리는 객체의 내부 구조를 묻지 말고, 무언가를 시켜야 한다.
디미터 법칙은 객체의 내부 구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 속삭인다.

## 디미터 법칙의 예외

한편, 객체가 아니라 자료구조라면 디미터 법칙을 거론할 필요가 없다. 자료 구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않기 때문이다.

## 주의: 디미터 법칙은 하나의 `.` 을 강제하는 규칙이 아니다

앞에서 설명한 것처럼 디미터 법칙은 "오직 하나의 도트만을 사용하라"는 말로 요약되기도 한다.
따라서 대부분의 사람들은 자바 8의 IntStream을 사용한 아래의 코드가 기차 충돌을 초래하기 때문에 디미터 법칙을 위반한다고 생각할 것이다.

```java
IntStream.of(1, 15, 20, 3, 9)
    .filter(x -> x > 10)
    .distinct()
    .count();
```

하지만 이것은 디미터 법칙을 제대로 이해하지 못한 것이다.
위 코드에서 `of`, `filter`, `distinct` 메서드는 모두 `IntStream` 이라는 동일한 클래스의 인스턴스를 반환한다.
즉, 이들은 `IntStream` 의 인스턴스를 또다른 `IntStream` 의 인스턴스로 변환한다.
기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.


## 참고

https://johngrib.github.io/wiki/law-of-demeter/