# Webpack

![](https://user-images.githubusercontent.com/35218826/59730847-eb233b00-927e-11e9-9788-408e699c9e58.png)

## Module 의 등장 배경

`webpack` 이 왜 쓰이는지를 이해하려면 javascript 모듈에 대해서 먼저 알아야 한다.

javascript 는 신기한 언어다. 가장 큰 차이점 중 하나는 파일이 다르다고 해서 서로 간에 접근을 못하는 것이 아니라는 점이다.
즉, 아래와 같이 서로 파일을 분리해 놓아도 `A.js`, `B.js` 순서대로 로딩만 한다면 에러 없이 동작한다.

```javascript
// A.js
var name = 'foo';
function getName() {
  return name;
}
// B.js
function sayHello() {
  alert('Hello ' + name); // Hello foo
}
sayHello();
``` 

웹 개발 초기에는 javascript 가 이정도로 고도화 줄은 꿈에도 몰랐을 것이고, 전역 스코프에 몽땅 변수들을 때려박는 것이 좀 더 개발하기 수월할 것이라고
생각했던 것일까? 왜 이렇게 설계되었는지에 대한 철학은 구글링을 해도 잘 나오진 않는 것 같다.

어쨌든 사람들은 javascript로 마구마구 거대한 코드를 찍어내기 시작했고 유지보수를 위해 코드 덩어리들을 나누어 관리하고 싶어했다.
전체 코드가 커질수록 코드 덩어리들은 점점 세분화되고 서로 간에 의존성이 얽히고 섥혀 모듈 레벨로의 관리가 필요해졌을 것이다. 마치 객체 지향 프로그래밍의
캡슐화가 나온 배경처럼 말이다.

그래서 javascript를 만든 사람들은 모듈 단위 개발을 위한 script type을 도입했다.
`<script type="module" src="./A.js">` 와 같이 `type`에 `module` 을 선언하여 명시적으로 export 하지
않는 이상 외부에서 접근이 되지 않도록 막았다. 이렇게 하면 전역 스코프가 오염되는 것을 막을 수 있을 뿐만 아니라, 한 모듈이 다른 모듈을 명시적으로 import
하기 때문에 의존 관계에 대한 표현력을 획득할 수 있다.

## Webpack 의 등장 배경 

모듈 단위의 개발이 성행하게 되면서 javascript 생태계에서는 프로젝트당 파일 수가 기하 급수적으로 늘어나게 되었다. 그러나 아무리 네트워크가 속도가 빨라졌다고
한들 이 많은 수의 파일을 동시에 로딩하면서 좋은 사용자 경험을 유지하기란 쉽지 않은 일이었고, 이러한 문제를 해결하기 위해 번들러가 등장하게 된다.
즉 번들러는, 말 그대로 **여러 파일들을 하나(혹은 여러 개)로 묶어주는 녀석**이다.

webpack은 또 여러 로더들을 이용해 번들링 커스터마이징도 가능하다.
대표적으로 많이 쓰이는 건 `babel-loader` 로, 이 친구는 브라우저간 표준화가 엉망인 javascript를 다양한 환경에서 동작할 수 있도록
문법변환(ES6 -> ES5 하는 식으로) 하여 문제 없이 동작할 수 있도록 한다. 

이 뿐 아니라, minify, uglify 라던지 여러가지 성능 향상을 위한 기능들도 함께 제공한다.
