# Clean Architecture

깨끗한 설계라는 건 도대체 무엇인가. 희미한 그 안개를 파헤쳐보자.

## 소프트웨어의 가치

우리는 왜 클린한 아키텍쳐를 원하는가. 소프트웨어의 가치를 높이기 위해서다.

소프트웨어의 가치는 다음 2가지로 측정되는 데, 이 중 첫 번째 항목을 훨씬 더 중요하게 바라보아야 한다.

1. 소프트웨어는 지속적으로 사용자들의 요구사항을 반영할 수 있어야 한다.
2. 소프트웨어가 기대한대로 잘 동작해야 한다.

아키텍쳐가 클린하지 않으면 1번 항목을 지켜내기가 힘들다.

## Architecture

사전적 의미는 다음과 같다.
> 전체적인 시스템 개발에 기반을 제공하는 변경 불가능한 초기 결정사항의 집합

ㅎㅎ 무슨 말인지 1도 모르겠다. 다음을 보자.

Architecture를 설명해달라는 질문에 Design pattern, Infra, Platform 등을 늘어놓는 사람이 많다.
이는 마치 설계 도면을 보여달랬더니 시멘트와 벽돌을 앞에 늘여놓고는 '건물이 벌써 눈 앞에 보이지 않냐'고 대답하는 것과 같다.

설계 도면을 보면 건물이 어떻게 생겼고, 그 건물 안에서 어떤 일(주거, 사무, 취식 등)들을 할 수 있는지 알 수 있어야 하는데,
이는 Software Architecture도 마찬가지다.
즉, Usage가 Architecture에 드러나야 한다. 그러니 벽돌을 보여주는 멍청한 사람이 되지 말자.

### Use Case

Architecture의 Usage를 보여주는 좋은 방법 중 하나는 바로 Use Case를 작성하는 것이다.
~~소공때 못생긴 졸라맨이 뭐가 중요한가 싶어 대충 들었더니 여기서 내 통수를 치네..~~  

작성하는 순서는 간단하다.
- ~~졸라맨~~Actor를 정의한다. (여기서 말하는 Actor란, 시스템을 사용하는 목적이 같은 사용자들의 집합이다)
- Actor가 시스템을 사용하는 목적에 맞는 기능을 정의한다.

Use Case에 집중하면, 도메인 로직이 보이고 이에 집중해야 아래에서 설명하는 Clean Architecture의 특징을 가져갈 수 있다.

### 결정사항 최대한 미루기(Deferring Decisions)

좋은 아키텍쳐는 결정사항을 뒤로 미룰 수 있다.

생각해보자. 어차피 우리는 고객의 요구사항대로 소프트웨어 개발을 해야 할텐데, 안타깝게도 고객조차 자신들이 무엇을 원하는 지 모른다.
고작해야 프로토타입을 직접 눈 앞에 가져다 보여주어야 이것이 내가 원하는 것이 맞다 아니다를 알 수 있는 정도다.
이 과정을 애자일스럽게 몇 번이나 지나고 나서야, 우리는 비로소 진정으로 고객이 원하는 게 무엇이었는지를 알게 된다.

바야흐로 unknown unknown(내가 뭘 모르는지조차 모르는 상태) 이 known unknown(내가 뭘 모르는지 아는 상태)으로 바뀌는 순간이다!
이렇게 되기 전에 섣부른 결정을 내렸다간 변경해야 할 코드가 엄청 많아져 헬게이트가 열리게 되는 것이다. 

> 번외 MVP([Minimum viable product](https://en.wikipedia.org/wiki/Minimum_viable_product))
>
> MVP에도 Clean Architecture를 적용해야 할까? 답은 아니다. MVP는 더럽고 추잡하더라도 빠르게 작성하는 게 목표다.
>
> 그러나 주의해야 할 점은, 이 MVP 코드를 실제로 프로덕트 개발을 시작할때 절대 사용하면 안된다는 것이다.
> 실제로 프로덕트 개발을 할 때는 깔끔하게 처음부터 시작해야 한다. 진흙집을 허물지 않고는 벽돌집을 지울 수 없다. 

### Design Smells
소프트웨어는 내버려두면 썩는다. 썩기 시작하면 다음 5가지 냄새가 난다.

- Rigidity (경직성)
    
    모듈을 변경하기가 너무 어렵다.

- Fragility (취약성)
    
    한 모듈을 수정하면 다른 모듈이 영향을 받는다.

- Immobility (부동성)

    모듈을 분리하기가 너무 힘들고 재사용하기도 까다롭다.

- Viscosity (점성)

    - 소프트웨어적 점성: 설계를 유지한 채로 코드 변경할 바에 설계를 뜯어고치는 게 낫겠다는 생각이 든다.
    - 환경적 점성: Test/Build 하는 시간이 너무 오래걸려서 쉽게 변경하기가 망설여진다.
    
    문제가 있는 걸 알면서 고치지 않으면(무책임한 용인) 소프트웨어의 점성도가 높아진다.

- Needless Complexity (쓸데없는 복잡성)

    미래의 변경사항을 너무 과하게 예측하는 바람에 코드가 복잡해졌다.
