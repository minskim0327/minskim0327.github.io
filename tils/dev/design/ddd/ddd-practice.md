# DDD Practice

DDD 아키텍쳐는 다음과 같이 4개의 영역으로 이루어져 있다.

- Presentation: 사용자(혹은 외부 시스템)와 맞닿는 부분이므로, 사용자의 요청을 처리하고 사용자에게 정보를 보여준다.

    - 사용자가 시스템을 이용할 수 있도록 화면 흐름을 제공하고 제어한다.
    - 사용자의 요청을 해석하여 그 요청에 맞게 Application을 실행한다.
    - 사용자의 세션을 관리한다.
    
- Application: 사용자가 요청한 기능을 presentation으로 부터 전달받아 실행한다.
    
    - 비즈니스 로직을 직접 구현하지는 않으며, **도메인 계층을 조합**해서 기능을 실행한다.
    - 트랜잭션을 관리하는데, 이는 리포지터리 구현 기술에 영향을 받는다.
    - 접근 제어와 도메인 이벤트 처리를 담당한다.
    
- Domain: 시스템이 제공할 도메인의 핵심 규칙을 구현한다.
    
    - 상태가 변경되면 도메인 이벤트를 발생시켜 Application 계층에 알릴 수 있다.
    
- Infrastructure: DB나 Messaging System(Kafka같은)과 같은 외부 시스템과의 연동을 처리한다.

DDD를 경험해보면서 가장 힘들었던 건 코드를 작성하는 내내 고민의 연속이었다는 점이다. 어디까지를 도메인 영역으로 봐야 하는가,
도메인 모델을 내가 잘 정의한 것이 맞는가, 이 Entity는 사실은 Value object 여야 하는 것이 아닌가, 
Aggregate 안에 어디까지를 포함시킬 것인가 와 같은... 쉽게는 답이 안나오는 것들이 태반이다.

아무래도 경험많이 내게 답을 내어줄 듯 하니, 실제로 조그만 시스템을 하나 설계해보며 고민을 정리해보려 한다. 

## 시스템 상태 모니터링

아주 간단하게 시스템 상태 모니터링 서버를 만든다고 해보자. 가지고 있는 기능은 단 하나다.
시스템 이름을 받아서 해당 시스템의 상태를 반환해주면 된다.

### Domain 파헤치기

가장 처음 해야할 것은 도메인 파헤치기다. 이걸 하기 위한 좋은 방법은 자기 자신에게 질문을 던지는 것이다.
어디까지가 도메인 영역이고, 어디까지가 구현 세부 사항인가?

그 질문에 대답하기 위해 이 시스템을 구현하는 데 있어서 필요해 보일만한 요소들을 나열해 보았다.

- 시스템의 이름
- 시스템의 상태
- 시스템의 상태를 어떻게 계산할 것인가
- 시스템의 상태를 계산할 근거는 무엇인가

구현하는 데 필요한 요소들을 나열하다 보면 기획에 구멍이 보인다. 요소에 명사가 적히는 게 아니라 질문이 적히기 때문이다.

논의를 거친 후에 리스트가 다음과 같이 바뀌었다고 하자.

- 시스템의 이름
- 시스템의 상태
- 시스템의 상태를 계산하기 위해 K8s에서 메트릭을 받아온다.
- 시스템의 상태는 K8s 메트릭을 분석하여 모든 pod가 살아 있다면 Green, 모든 pod가 죽어 있다면 Red, 그 외에는 Yellow 로 한다. 

이것만 가지고 개발을 할 수 있는가? 도메인을 파헤칠 때는 최대한 면밀히 따져보아야 한다.

- 시스템의 이름
- 시스템의 이름을 찾을 수 없는 경우에는 SystemNotFoundError 를 던진다.
- 시스템의 상태
- 매트릭을 받아오는 서비스
- K8s 메트릭을 받아오는 데 실패하는 경우는 존재하지 않는다고 가정하고, 에러가 발생하는 경우만 따로 로깅한다.
- 상태를 계산하는 서비스
- 시스템의 상태는 K8s 메트릭을 분석하여 모든 pod가 살아 있다면 Green, 모든 pod가 죽어 있다면 Red, 그 외에는 Yellow 로 한다. 

이제 문제는 어디까지를 도메인 영역으로 볼 것인가? 이다. 어디까지가 도메인인지 정해지고 구현이 끝난 후에 이 범위를 다시 변경하려면
큰 고통을 감수해야 한다. 모든 레이어가 도메인에 의존할 수 있으므로, 도메인이 변경되면 다른 레이어가 얼마든지 변경될 수 있기 때문이다.
따라서 나는 어디까지를 도메인으로 보아야하는지 고민할 때 신중해지는 편이다.

#### 주의해야 할 점

예전에 나는 '3rd-party와 관련된 것들은 도메인이 될 수 없어. 무조건 인프라야'라고 생각했는데, 이는 틀린 생각이었다.
가령 위의 예시에서 도메인 영역을 다음과 같이 뽑았다고 해보자.

- 시스템의 이름 (도메인)
- 시스템의 이름을 찾을 수 없는 경우에는 SystemNotFoundError 를 던진다. (어플리케이션)
- SystemNotFoundError (도메인)
- 시스템의 상태 (도메인)
- 매트릭을 받아오는 서비스 (인프라)
- K8s 메트릭을 받아오는 데 실패하는 경우는 존재하지 않는다고 가정하고, 에러가 발생하는 경우만 따로 로깅한다. (인프라)
- 상태를 계산하는 서비스 (인프라)
- 시스템의 상태는 K8s 메트릭을 분석하여 모든 pod가 살아 있다면 Green, 모든 pod가 죽어 있다면 Red, 그 외에는 Yellow 로 한다. (인프라) 

물론 이와 같이 도메인 영역을 잡고 구현에 들어가도 전혀 문제가 되지 않는다. 하지만 이 설계가 좋은 설계인지에 대해서는 의심이 든다.
도메인만 보고 이 시스템에 이해하기가 어렵기 때문이다.
처음 이 시스템을 마주한 사람은 '시스템의 상태가 있고, 이름이 있어. 근데 뭐?' 라는 생각이 들 것이다. 처음 시스템을 마주한 사람의
페르소나를 연기하다보면 무엇이 이 시스템의 핵심이자 본질인지 파악하기가 쉬워진다. Green, Yellow, Red로 시스템의 상태를 계산하는
저 우스꽝스러운 로직 자체가 바로, 다른 곳에서는 볼 수 없는 이 시스템의 핵심이다. 즉, 목록은 다음과 같이 다시 쓸 수 있다.

- 시스템의 이름 (도메인)
- 시스템의 이름을 찾을 수 없는 경우에는 SystemNotFoundError 를 던진다. (어플리케이션)
- SystemNotFoundError (도메인)
- 시스템의 상태 (도메인)
- 매트릭을 받아오는 서비스에 대한 인터페이스 (도메인)
- 매트릭을 받아오는 서비스 (인프라) // K8s 메트릭을 제품 메트릭으로 변환한다.
- 상태를 계산하는 서비스 (도메인) // 로직이 여기서 드러나게 될 것이다.
- 제품 메트릭 (도메인)

로직을 도메인 레벨에서 드러나도록 하기 위해, 제품 메트릭이라는 추상적인 모델이 새로이 등장하였다. 도메인에 대해 파고들다 새로운
도메인 모델을 발굴한 경우다. 이로서 시스템을 처음 마주한 사람은 '아 이름을 받아서 제품 메트릭을 얻어오고 이런 로직으로 계산하는 구나'
를 도메인 레벨의 코드만 보고도 깨닫게 된다.

하지만 그렇다고 해서 무턱대고 비즈니스 로직들을 도메인 레벨로 끌어올려선 안된다. 구현 세부사항들로 도메인이 더럽혀지기 때문이다.

## 구현 순서

보통은 도메인 레벨에서 부터 구현한다. 사실 도메인의 범위를 

