# Domain Driven Design

![](https://devpath.pro/wp-content/uploads/2020/03/model-driven-design.png)

## 1. Domain

### Domain

Domain은 **소프트웨어로 풀고자 하는 문제 영역**이다. Domain은 여러 하위 Domain으로 구성될 수 있다.
이러한 Domain을 개념적으로 표현한 것을 **Domain Model** 이라 한다.
Domain Model은 요구사항들을 정련(분석)하는 과정에서 점진적으로 도출된다. 즉, 요구사항 분석이 선행되어야 DDD를 적용할 수 있다.

의외로 가장 헷갈리는 것이 Domain과 Infra의 구분이다. 얼핏 생각하면 쉬울 것 같다. Database 처럼 로우한 레벨이 infra 고,
사용자, 제품 같은 하이레벨 Model이 Domain 이 아닌가? 항상 그런 것만은 아니다. 소프트웨어가 Database를 관리하는 시스템이라면
Database 역시 Domain Model 로써 표현될 수 있다.

내가 했던 경험을 예로 들어 설명하자면, 나는 Http Live Streaming을 이용해 영상/오디오에 자막을 달아 스트리밍을 송출하는
소프트웨어를 개발 중이었다. 나는 RFC 표준에서 명세되고 있는 HLS의 여러 개념들이 당연히 Domain 로직이 될 것이라고 생각하고
열심히 (표준에 명시된 로직들을 반영하며) 도메인 계층의 코드를 짰으나, 팀원분의 말씀을 듣고 전부 Revert 시킬 수 밖에 없었다.

"가능하면 HLS 를 RTMP 로 변경해도 도메인 로직에는 변경이 안생기는게 이상적이지 않을까요?"

머리를 망치로 세게 얻어맞은 느낌이었다. 소프트웨어를 해석하는 관점 자체가 달랐던 것이다.
우리가 풀려고 했던 문제는 '영상/오디오에 자막을 어떻게 하면 문제없이 담아내어 송출할 수 있는가' 였지,
'오디오/미디어/자막 파일들을 HLS로 서빙할 수 있는가'가 아니었다.

이어서 나는 팀원분의 도메인과 인프라를 구분짓는 기준을 물었다.

"소프트웨어가 수행하는 추상화된 개념이나 정책이 Domain이 되고,
이러한 Domain 로직을 달성하기 위한 기술적인 수단이 Infra 라고 이해하고 있습니다."

## 2. 아키텍쳐

### 4개의 영역

DDD 아키텍쳐는 다음과 같이 4개의 영역으로 이루어져 있다.

- Presentation: 사용자(혹은 외부 시스템)와 맞닿는 부분이므로, 사용자의 요청을 처리하고 사용자에게 정보를 보여준다.

    - 사용자가 시스템을 이용할 수 있도록 화면 흐름을 제공하고 제어한다.
    - 사용자의 요청을 해석하여 그 요청에 맞게 Application을 실행한다.
    - 사용자의 세션을 관리한다.

- Application: 사용자가 요청한 기능을 presentation으로 부터 전달받아 실행한다.

    - 비즈니스 로직을 직접 구현하지는 않으며, **Domain 계층을 조합**해서 기능을 실행한다.
    - 트랜잭션을 관리하는데, 이는 리포지터리 구현 기술에 영향을 받는다.
    - 접근 제어와 Domain 이벤트 처리를 담당한다.

- Domain: 시스템이 제공할 Domain의 핵심 규칙을 구현한다.

    - 상태가 변경되면 Domain 이벤트를 발생시켜 Application 계층에 알릴 수 있다.

- Infrastructure: DB나 Messaging System(Rebbit MQ, Kafka같은)과 같은 외부 시스템과의 연동을 처리한다.

> 여기서 말하는 Domain의 핵심 규칙이란, '주문 취소는 배송 전에만 할 수 있다'와 같은 규칙을 말한다.

위와 같은 아키텍쳐에서 다른 레이어가 Infra 레이어에 의존할 경우 테스트가 어려워지고 기능이 확장되기 힘들어지는데, DIP를 이용해 이를 해결할 수 있다.
DIP를 이용하면 저수준 모듈이 고수준 모듈에 의존(Infra 계층이 응용이나 Domain에 의존)하게 되면서 Maintainability와 flexibility가 향상된다.
이는 또한, 모든 레이어가 Domain 레이어에 의존하게 되는 의미도 가진다.

이 때 주의할 점은 DIP를 적용하기 위해 인터페이스를 도출할 때, 저수준 모듈의 관점이 아니라 고수준 모듈의 관점에서 도출해야 한다.
즉, 인터페이스에 '상위 모듈에서 어떠어떠한 기능이 필요해'가 기술되어야 하지, '저수준 모듈에서 이러이러한 걸 제공해'가 드러나선 안된다는 것이다.

이를 개발 방식에 반영하면, 고수준 레벨의 코드 -> 저수준 레벨의 코드 순으로 커밋이 가능하다. 고수준 레벨에서 어차피 저수준 레벨의 코드는
인터페이스만 사용하여 개발한 뒤, 나중에 고수준 모듈의 요구사항에 맞추어 저수준 레벨의 코드를 구현해주기만 하면 되기 때문이다.
즉 domain -> application -> infra -> presentation 순으로 자연스러운 코딩이 가능하다.

### Domain 영역의 주요 구성요소

(에릭 에반스의 Domain 주도 설계에 기반한)Domain 영역을 좀 더 깊게 파보자. 주요 구성 요소는 다음과 같다.

- 엔티티(Entity): 고유의 식별자와 라이프사이클을 갖는 객체다.

    - 객체이기 때문에 행동(기능)과 상태(데이터)를 지닌다.

- 벨류 오프젝트(Value Object): 개념적으로 하나인 Domain 객체의 속성을 표현하기 위해 사용된다.

    - 엔티티의 속성 뿐만 아니라 다른 벨류의 속성으로도 사용된다.
    - 따라서 Immutable 해야 한다.

- 애그리거트(Aggregate): 개념상 완전한 한 개의 Domain 모델을 표현한다. 

    - 서로 관련있는 엔티티와 벨류들을 하나로 묶은 것이다.
    - 묶여진 집합에 속한 객체들을 관리하는 루트 엔티티를 가진다.

        - 루트 엔티티는 집합에 있는 엔티티와 벨류들을 이용해서 애그리거트가 구현해야 할 기능을 제공한다.
        - 즉, 에그리거트는 캡슐화되어 애그리거트 루트 부분만을 외부로 노출시킨다.

- 리포지터리(Repository): 엔티티 객체를 Infra로부터 로딩하거나 저장하는 기능을 제공한다.

    - 리포지터리는 애그리거트 단위로 Domain 객체를 저장하고 조회하는 기능을 정의한다.
    - 리포지터리의 사용주체가 응용 계층이기 때문에, 이 계층이 필요로하는 다음 2가지 인터페이스를 기본적으로 제공한다.

        - 애그리거트를 저장
        - 애그리거트 루트 식별자로 조회
        - 추가적으로 필요에 따라 delete(id)나 counts()를 제공한다.

- Domain 서비스(Domain Service): 여러 엔티티와 벨류를 필요로 하여 특정 엔티티에서 구현하기 힘든 로직을 제공하기 위해 사용한다.

> 리포지터리가 엔티티 객체를 로딩하거나 저장한다고 해서 DB 스키마를 엔티티와 동일하게 설계해야 한다고 오해해선 안된다.  
> 서로 다른 것임을 알 수 있는 단적인 예로, Domain 모델의 엔티티는 기능을 함께 제공하지만 스키마는 그렇지 않다.  
> 위에 언급한 바와 같이, 리포지터리는 애그리거트 와 1:1로 대응이 되어야 한다.

즉, 큰 그림으로 봤을 때 Infra에서 애그리거트를 가져오고, 애그리거트는 기능을 가지고 있으므로 그 기능을 어플리케이션에서 호출한다.

### 모듈 구성

다음 소스트리를 참고하자.
```
myApp // 풀고자하는 문제 영역들이 패키지 이름에 드러나게 되어, 소스코드를 보지 않고도 대략 이 앱이 어떤 일을 하는지 알 수 있다.
├── domain_name1    // 아래와 같이 레이어가 드러나도록 하는 것이 좋다.
│   ├── ui
│   │   └── ...
│   ├── application
│   │   └── ...
│   ├── domain
│   │   └── ...
│   └── infrastructure
│       └── ...
├── domain_name2    // 만약 특정 계층의 크기가 10개의 파일이 넘어갈 정도로 너무 크다면 아래 처럼 sub_**로 분리해도 좋다.
│   ├── ui
│   │   └── ...
│   ├── application
│   │   └── ...
│   ├── domain
│   │   ├── sub_domain_name1
│   │   │   └── ...
│   │   └── sub_domain_name2
|   |       └── ...
│   └── infrastructure
│       └── ...
├── ...
```

## 3. 애그리거트

### 애그리거트

> 애그리거트는 엔티티와 벨류를 묶은 집합체라고 했는데, 어떤 기준으로 묶어야 할까?

결국은 요구사항으로부터 출발해야 한다.
요구사항으로부터 Domain 규칙을 뽑아내고, 이 규칙에 따라 **한꺼번에 같이 변경**되어야 하거나 **같이 생성**되어야 하는 객체들을 한 애그리거트로 묶어보는 것으로 시작한다.
애그리거트에 한 번 속한 객체는 다른 애그리거트에 속하지 않으므로 차례차례 줄여나가다 보면 애그리거트를 완성할 수 있을 것이다.

흔히 'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있다면 이를 한 애그리거트에 속하도록 만들기 쉬울 텐데, 반드시 그래야 하는 것은 아니다.
예를 들어 '상품'은 '리뷰'를 가지고 있지만 둘이 같이 생성되지도, 같이 변경되지도 않는다.

애그리거트는 서로 최대한 독립적이어야 하는데, 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간 결합도가 높아지게 된다.
이는 Maintainability를 매우 떨어뜨리므로 조심해야 한다. 만약 반드시 의존해야 하는 상황이라면, 애그리거트가 다른 애그리거트를 직접 변경하는 것이 아니라,
응용 서비스에서 두 애그리거트를 동시에 수정하도록 구현해야 한다.

### 애그리거트 루트

애그리거트 루트는 마치 안내데스크 관리자 같다. 애그리거트 밖에서는 이 관리자랑만 소통해야 하며, 안에서는 밖에 누가 왔는지 관심이 없다. 
관리자는 애그리거트 내부의 다른 객체들을 조합해서 기능을 완성하여 밖에 그 기능을 제공한다.

### 애그리거트끼리 연관되어 있는 경우 

애그리거트 내부에서는 애그리거트 루트가 다른 엔티티나 벨류를 직접적으로 참조할 수 있지만, 외부에서 한 애그리거트가 다른 애그리거트를 
참조하는 경우 절대 직접 참조를 해선 안된다(커플링이 생기기 때문이다). 대신 해당 애그리거트 루트의 식별자를 이용해서 다음과 같이 간접적으로 참조한다.

```java
// Order 애그리거트
public class Order extends AggregateRoot {
  private Orderer orderer;
}

// Order 엔티티
public class Orderer extends Entity {
  private MemberId memberId;
}

// Member 애그리거트
public class Member extends AggregateRoot {
  private MemberId id;
}
```

이렇게 하면 애그리거트간 커플링을 줄이고, 응용서비스에서 필요에 따라 이 식별자를 이용해 애그리거트를 로딩하여 사용할 수 있다.
그런데, 위와 같이 1:1 연관이 아니더라도 1:N, M:N 과 같은 집합 연관이 발생할 수 있다.

1:N 관계에서 직접 참조를 하지 않아야 하므로 다음과 같이 구현한다. 하나의 `Category` 안에 여러 `Product` 가 존재하는 경우다. 

```java
public class Product {
  private CategoryId categoryId;
}

// 응용 서비스.
// 사실 Presentation계충에 필요한 Page<Product>를 리턴해야 하지만 간소화를 위해 Set를 리턴하도록 했다.
public class ProductListService {
  public Set<Product> getProductsOfCategory(CategoryId categoryId) {
    Set<Product> products = productRepostory.findAllByCategoryId(categoryId);
    return products;
  }
}
```

다음과 같이 하면 M:N 구조를 표현할 수 있다. 하나의 `Category` 안에 여러 `Product` 가 존재할 수 있고, 하나의 `Product` 안에 여러 `Category`가 또한 존재할 수 있는 경우다.

```java
public class Product {
  // Product나 Category 둘 중 하나만 Set<*Id>만 가지고 있으면 된다.
  // 응용서비스에서 join을 쓰면 되기 때문에 딱히 Category가 Set<ProductId>를 가질 필요가 없기 때문이다.
  private Set<CategoryId> categoryIds;
}
``` 

### 애그리거트를 팩토리로 사용하기

아래와 같이 Domain 로직이 응용서비스에 노출되는 경우가 있다.

```java
// 응용 서비스
public class RegisterProductService {
  public ProductId registerNewProduct(NewProductRequest request) {
    // ...
    if (!account.canSaveNewProduct) {
      throw new Error
    }
    ProductId id = productRepository.nextId();
    Product product = new Product(id, ownerName, ...); // Account로부터 알 수 있는 여러 정보들을 인자로...
    productRepository.save(product);
  }
}
```

위와 같이 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메소드를 구현하는 게 좋다.

## 4. 리포지터리와 모델 구현

### 리포지터리 구현

리포지터리는 애그리거트의 저장소를 표현한다. 이 때 애그리거트를 어떤 저장소에 저장하느냐에 따라 리포지토리 구현하는 방법이 달라진다.
그러나 어떤 저장소를 쓰든 리포지터리의 기본 기능은 다음 두 가지다.
- 아이디로 애그리거트 조회
- 애그리거트 저장

이 기능을 표현하는 인터페이스는 애그리거트 루트를 기준으로 작성한다.
```java
interface OrderRepository {
  public Order findById(OrderId id); // findBy는 거의 convention이다.
  public void save(Order order);
}
```

만약 아이디가 아닌 다른 조건으로 애그리거트를 조회해야 하는 경우 findBy뒤에 조건 대상이 되는 프로퍼티 이름을 붙인다.
```java
interface OrderRepository {
  // ...
  public List<Order> findByOrdererId(OrdererId ordererId);
}
```

### 애그리거트 로딩 전략

애그리거트가 완전해야 하는 이유는 2가지 인데,

1. 상태를 변경하는 기능을 실행할 때 애그리거트 상태가 완전해야 하고
2. 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다

이를 유념하고 아래 기능들을 구현해야 한다.

- 조회: 개념적으로는 한 번에 몽땅 로딩하는 것이 맞으나, 애그리거트가 완전해야 하는 이유를 해치지 않는 선에서 지연 로딩을 써도 좋다. 
- 저장: 애그리거트 루트만 저장하면 안 되고 애그리거트에 속한 모든 객체를 저장해야 한다.
- 삭제: 애그리거트 루트 뿐만 아니라 애그리거트에 속한 모든 객체를 삭제해야 한다.

저장과 삭제는 Cascade를 사용하면 편리하다.

## 5. 리포지터리의 조회 기능

### 검색을 위한 스펙

위 처럼 id로만 검색하는 것이 아닌, 가끔 검색 조건이 너무 다양하고 복잡한 경우가 있다. 이 때는 스펙을 이용해서 문제를 풀어야 한다.
스펙은 애그리거트가 특정 조건을 충족하는지 여부를 검사한다. 인터페이스로 다음과 같이 표현할 수 있다.

```java
interface Specification<T> {
  public boolean isSatisfiedBy(T aggregate); // aggregate는 검사 대상이 되는 애그리거트 객체다.
}
```

리포지터리는 스펙을 전달받아 애그리거트를 걸러내는 필터로 사용한다.

```java
Specification<Order> ordererSpec = new OrdererSpec();
List<Order> orders = orderRepository.findAll(ordererSpec);
```

#### 스펙의 조합

스펙의 꽃은 조합이다. 두 개 이상의 스펙을 AND 하거나 OR 하여 새로운 스펙을 만들어 낼 수 있다.

```java
class AndSpecification<T> implements Specification<T> {
  private List<Specification<T>> specs;

  public AndSpecification(Specification<T> ...specs) {
    this.specs = Arrays.asList(specs);
  }
  
  public booelan isSatisfiedBy(T aggregate) {
    for (Specification<T> spec : specs) {
      if (!spec.isSatisfiedBy(aggregate)) {
        return false;
      }
    }

    return true;
  }
}
```

## 6. 응용 서비스와 표현 영역

### 표현 영역과 응용 영역

표현 영역에서는 사용자의 요청을 응용 영역이 요구하는 객체의 모양대로 만들어 넘겨준 뒤 해당 계층에게 기능 실행을 위임한다.

응용 영역에서는 리포지터리로부터 Domain 객체를 구하고, 이 객체들을 사용하여 넘겨 받은 요청을 처리한다.
사용자 입장에서 보았을 때 응용 서비스는 Domain 영역과 표현 영역을 연결해 주는 창구인 파사드(facade) 역할을 한다.
주로 다음과 같은 단순한 형태를 갖는다.
1. 리포지터리에서 애그리거트를 가져온다.
2. 애그리거트의 Domain 기능을 실행한다.
3. 결과를 리턴한다.

애그리거트를 생성하는 경우도 마찬가지로 단순하다.
1. 데이터가 유효한지 검사한다.
2. Factory 메소드로 애그리거트를 생성한다.
3. 리포지터리에 애그리거트를 저장한다.
4. 결과를 리턴한다.

> 응용 서비스가 이것보다 복잡하다면 Domain 로직의 일부를 구현하고 있을 가능성이 높다.

Domain 로직이 응용 계층에 구현되면 어떤 문제점이 생길까?
- Domain 로직을 파악하기 위해 여러 영역을 파헤쳐야 한다. 즉, 코드의 응집성이 떨어진다.
- 한 번이 어렵지, 두 번은 쉽다. 여러 응용 서비스에서 동일한 Domain 로직을 구현할 가능성이 높아진다. 즉, 코드 중복이 발생한다.

### 응용 영역과 트랜젝션

응용 영역의 또 다른 중요한 기능 중 하나는 트랜젝션 관리이다.
Domain의 상태 변경을 트랜젝션으로 처리해야 하는데, 이 관리가 제대로 되지 않는다면 데이터의 일관성이 깨지게 된다. 

### 응용 서비스의 구현

한 Domain과 관련된 기능을 하나의 응용 서비스 클래스로 만들기 보다, 한 Domain 안에서 구분되는 기능을 가진 별도의 서비스 클래스로 구현하는 게 좋다.
이 때, 중복된 코드가 여러 클래스에 나타날 수 있는데, Helper등을 만들어 중복된 코드를 뽑아내는 것도 방법이다.

#### 인터페이스의 필요성

표현 영역에서 응용 영역을 실행하려면 인터페이스가 필요하지 않을까?

인터페이스는 구현 클래스가 여러 개인 경우에 유용한데, 응용 서비스는 그럴 일이 드물다. 따라서 정말로 필요한 경우에만 인터페이스를 구현하지 않으면
파일이 쓸데 없이 많아져 전체 구조가 복잡해지는 결과를 낳는다.

#### 응용 서비스의 메소드

파라미터로 필요한 데이터를 각각 따로 받을 수도 있지만, 데이터 클래스를 선언하여 한 번에 받는 것이 가독성에 더 좋다.
만약 표현 영역에서 응용 서비스의 결과가 필요하다면 그 결과를 리턴해주면 된다. e.g. 주문 실행 후 주문번호 반환

그러나 애그리거트 자체를 리턴하지 않도록 조심해야 한다. 애그리거트는 데이터 뿐만 아니라 기능을 같이 포함하고 있기 때문에, 애그리거트를 리턴하게 되면
응용 서비스 뿐만 아니라 표현 영역도 기능 실행 능력이 생겨 코드 응집도가 떨어진다. 그러므로 반드시 필요로 하는 데이터만 리턴해주어야 한다.

#### Domain 이벤트 처리

Domain 이벤트란 Domain 영역에서 발생한 상태 변경을 의미한다. e.g. 암호 변경됨, 주문 취소함

Domain 영역은 상태가 변경되면 이를 외부에 알리기 위해 이벤트를 발생시킬 수 있다.
이벤트를 사용하는 이유는 Domain 간의 의존성이나 외부 시스템에 대한 의존을 낮춰주는 장점을 얻을 수 있기 때문이다. 

### 값 검증

원칙적으로는 모든 값에 대한 검증은 응용 서비스에서 처리해야 한다.
그러나 이와 같은 결정이 사용자 경험을 해치는 경우이거나 응용서비스에서 처리하려면 복잡한 코드가 추가되어야 하는 경우에 한해 표현 영역에서도 값에 대한 검증을 수행할 수 있다.

결국 경험적으로 값 검증에 대해서는 다음과 같이 귀결된다.
- 표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다.
- 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증한다.

### 권한 검사

'사용자 U가 기능 F를 실행할 수 있는가'와 같은 권한 검사는 보통 다음의 세 곳에서 수행할 수 있다.
- 표현 영역: 인증된 사용자인지 아닌지 검사한다.
- 응용 서비스: URL만으로 접근제어를 할 수 없는 경우 응용 서비스 메소드 단위로 권한 검사를 해야 한다.
- Domain: 응용 서비스 메소드 수준에서 권한 검사를 할 수 없는 경우 Domain 레벨에서 권한 검사를 한다.

### 조회 전용 기능과 응용 서비스

응용 서비스를 통해 어떤 애그리거트를 조회할 때, Domain 서비스의 메소드 하나 달랑 호출하는 식으로 코드가 엄청나게 간단해질 경우가 있다.
이럴 때는 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 된다.

## 7. Domain 서비스

### 여러 애그리거트가 필요한 기능

결제 금액을 계산하는 기능을 구현한다고 했을 때, 다음 중 어느 애그리거트가 주체가 되어 계산을 해야 할까?
- 상품 애그리거트: 상품의 가격 알고 있음
- 주문 애그리거트: 구매 개수와 배송비 알고 있음
- 할인 쿠폰 애그리거트: 할인율 알고 있음
- 회원 애그리거트: 프리미엄 혜택을 알고 있음

정답은 '**아무에게도 책임을 위임해서는 안된다**'이다.
특정 기능을 위해 다수의 애그리거트를 이용해야 한다면 그 기능에 대한 Domain 서비스를 구현하는 게 맞다.

### Domain 서비스

Domain 서비스는 상태를 가지지 않고, 로직만 들고 있는 서비스다. 이 때 필요한 상태가 있다면 다른 애그리거트로부터 전달받아야 한다.
Domain 서비스를 사용하는 곳은 애그리거트가 될 수도 있고, 응용 서비스가 될 수도 있다.
다만 애그리거트에서 Domain 서비스를 사용하는 경우에는 응용 서비스가 애그리거트에게 해당 Domain 서비스를 전달해줄 의무를 갖는다.
즉 Domain 서비스의 생성은 응용 서비스로부터 시작된다.

이 때, Domain 서비스 객체를 DI framework등을 통해서 애그리거트에 주입을 하고 싶어질 수도 있는데, 이는 별로 좋은 방법이 아니다.
애그리거트는 프로퍼티와 메소드들을 통해 개념적으로 하나의 모델을 표현할 수 있어야 한다.
그러나 여러 애그리거트에 걸쳐진 Domain 서비스를 애그리거트의 필드로 가져가는 건 오히려 모델을 표현하는 데 방해되므로 철학적으로 위배된다.

Domain 서비스는 Domain 로직을 실행하므로 Domain 계층에 있는 것이 맞다. 따라서 다른 엔티티 벨류 들과 동일한 패키지에 위치시킨다.

만약 Domain 서비스가 어떠한 특정 기술에 의존적이라면 서비스를 인터페이스와 구현 클래스로 분리하고 인터페이스만 Domain 영역에 남겨둔 채 해당 구현 클래스들을 Infra 스트럭쳐 레이어에 종속시키게 될 수도 있다.
이를 통해 Domain 영역이 특정 구현에 종속되는 것을 방지할 수 있고 Domain 영역에 대한 testability를 높일 수 있다.

## 8. 애그리거트 트랜젝션 관리

### 애그리거트와 트랜잭션

> 주문 애그리거트를 운영자가 배송 상태로 변경할 때 사용자가 배송지 주소를 변경하게 되면 어떻게 처리해야 할까?

트랜잭션마다 레포지터리는 새로운 애그리거트를 생성하므로 위와 같이 두 명 이상의 사용자가 거의 동시에 한 애그리거트를 변경할 때 우리는 반드시 트랜젝션을 사용해야 한다

트랜잭션에는 선점과 비선점 2가지 방식이 있다.

#### 선점 잠금

선점 잠금은 먼저 애그리거트를 구한 스레드가 사용이 끝날 때까지 다른 스레드로부터의 수정을 막는 방식이다.
- 고객은 '이미 배송이 시작되어서 배송지를 변경할 수 없습니다' 메시지를 보게 된다.
- 데드락의 위험성이 있다.
    - 스레드 1, 2가 동시에 애그리거트 A, B 를 선점해놓고 각각 서로를 변경하려고 하면 영원히 잠기게 되는 문제가 생긴다.
        - 이는 최대 대기시간을 지정해서 해결할 수 있다.
- 모든 상황을 커버칠 수는 없다.
    - 운영자가 배송지 정보를 조회하고 배송 상태로 변경하는 사이 고객이 배송지를 변경하는 경우

#### 비선점 잠금

비선점 잠금은 잠금으로 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 db에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.
- db 테이블에 버전을 두고, 트랜젝션을 할 때 해당 버전의 데이터만 수정할 수 있도록 한다. 만약 트랜잭션이 성공하면 테이블 버전이 올라가는데, 버전이 맞지 않는 경우 트랜잭션 커밋이 실패한다.

응용서비스에서는 어떤 동작까지가 한 트랜잭션에 포함되는지를 설정하고, 만약 이 트랜잭션이 커밋 실패와 같은 이유로 exception이 발생하면 표현영역에서 이를 처리하게 된다.

### 오프라인 선점 잠금

비선점 잠금의 단점을 보완하고자 나온 것이 오프라인 선점 잠금이다.
예를 들어 위키 페이지의 동시 수정을 가능하게 하고 싶은 경우 비선점 잠금 방식의 경우 버전이 다르기 때문에 나중에 들어갈 커밋은 실패하게 된다.

오프라인 선점 잠금 방식은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.
그 트랜잭션들 중 첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다.
잠금을 해제하기 전까지 다른 사용자는 잠금을 선점할 수 없다. 또, 오프라인 선점 잠금 방식은 유효기간을 가져야 하는데, 이 유효기간은 연장 기능이 포함되어야 한다.

TODO: 여기 무슨 말인지 모르겠는데 나중에 다시 봐야겠다.

## 9. Domain 모델과 Bounded Context

### Domain 모델과 경계

> 처음 Domain 모델을 만들 때 빠지기 쉬운 함정이 Domain을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다.

그러나 하나로 완벽하게 표현하려고 하다보면 두 가지 문제가 생긴다.
- 상품 Domain에서 상품은 상품에 대한 정보를 담고 있다면, 재고 관리Domain에서 상품은 개별 객체를 추적하는 데 쓰인다.
    - 재고관리 Domain에서는 여러 개일 수 있는 상품이 상품 Domain에서는 단 한 개만 존재해야 한다.
- 같은 대상일지라도 하위 Domain에 따라 다르게 불려야 하는 경우가 있다.
    - 주문 Domain에서는 주문자였던 객체가, 회원 Domain에서는 회원으로 표현되어야 할 수 있다.

따라서 우리는 하위 Domain 마다 모델을 만들어야 한다. 각 모델은 명시적으로 구분되는 경계를 가져서 서로 섞이지 않도록 해야 한다.
이 모델은 특정한 컨텍스트 안에서 완전한 의미를 갖는데, 이렇게 구분되는 경계를 갖는 context를 Bounded context라고 부른다.

### Bounded Context

> 한 개의 Bounded Context는 하나의 마이크로 서비스로 떼어낼 수 있어야 한다.

한 개의 Bounded context는 논리적으로 한 개의 모델을 갖는다. Bounded context는 용어를 기준으로 구분한다.

이상적으로 하위 Domain 하나가 Bounded context하나에 대응되면 좋겠지만, 현실적으로 그게 쉽지 않다.
때문에 여러 하위 Domain을 하나의 Bounded context에서 개발하게 되는 경우가 종종 있는데, 이 때 주의할 점은 하위 Domain의 모델이 뒤섞이지 않도록 해야 한다는 것이다.
그러기 위한 방법으로 하위 Domain마다 구분되는 패키지를 갖도록 하는 방법이 있다.

Bounded context는 각자 구현하는 하위 Domain에 맞는 모델을 갖는다. 이 모델은 애그리거트가 될 수도 있고, 그냥 단순한 Value가 될 수도 있다.
또 한 Bounded context는 서로 연관되는 여러 애그리거트를 포함할 수도 있다.

### Bounded Context의 구현

Bounded Context는 Domain 모델 뿐만 아니라 Domain 기능을 사용자에게 제공하는 데 필요한 표현 영역, 응용 서비스, Infra 영역 등을 모두 포함한다.
이 때 모든 Bounded context를 반드시 Domain 주도로 개발할 필요는 없다.
대표적인 예가 바로 CQRS(Command Query Responsibility Segregation)패턴이다.

### Bounded Context간 통합

Bounded Contexst끼리 통합되어서 기능을 구현해야 하는 경우도 있다.
이 때 REST API를 뚫어서 서로 통신하게끔 하거나, Message Queue를 사용하거나 Pub/Sub 모델을 이용해 Context들을 통합할 수 있다.

### Bounded Context간 관계

Bounded Context들 끼리는 어떤 식으로는 연결되기 때문에 다음과 같이 여러 관계를 맺는다.
- 고객/공급자 관계: 한쪽이 API를 제공하고 다른 한 쪽이 그 API를 호출하는 관계
- 공유 커널 관계: 두 Bounded Context가 같은 모델(Shared Cernal)을 공유하는 경우.
- 독립 방식 관계: 서로 통합하지 않는 관계

### Context 맵

특정 Bounded Context에 매몰되면 전체를 보지 못할 때가 있는데, 이 때 필요한 것이 Context 멥이다.
컨텍스트 맵은 전체 시스템의 이해 수준을 보여준다. 즉, 시스템을 더 잘 이해하거나 시간이 지나면서 컨텍스트 간 관계가 바뀌면 컨텍스트 멥도 함께 바뀐다.

그리는 규칙은 따로 없으나, Context간의 관계가 집중적으로 조명되어야 한다.

## 10. 이벤트

### 이벤트 개요

시스템 간 결합이 강하게 작용되면 트랜젝션 처리가 애매해지고 로직이 뒤섞여서 유지보수가 어려워지는 등 여러 문제점이 생긴다.
따라서 결합도를 낮추기 위해 우리는 이벤트를 사용할 수 있다.

이벤트란 '과거에 벌어진 어떤 것'을 의미한다. Domain 모델에 이벤트를 도입하려면 다음 4개의 구성요소를 구현해야 한다.
- 이벤트: 이벤트에 대한 정보를 담은 데이터 객체
    - 클래스 이름으로 이벤트 종류를 표현한다. 이 때, 이미 발생한 사건이므로 과거 시제를 사용한다.
    - 이벤트 발생 timestamp와 추가 (이벤트를 처리하는 데 필요한)데이터 를 가지고 있다.
- 이벤트 생성 주체: 엔티티, Domain 서비스와 같은 Domain 객체, 디스패쳐에 이벤트를 전달한다.
- 이벤트 핸들러: 이벤트에 반응하여 처리한다.
- 이벤트 디스패쳐(퍼블리셔): 핸들러와 생성 주체를 연결해준다. 전달받은 이벤트를 해당 이벤트를 처리할 수 있는 핸들러에게 전파한다.
    - 디스패쳐의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.

이벤트를 사용하면서 얻을 수 있는 가장 큰 장점은 역시 디커플링이다.
가령, 주문 취소시 환불을 해야한다고 할 때 주문이 취소시키는 코드에 환불 로직을 포함하고 있을 이유가 없어진다.
즉, Domain 이벤트를 추가하기만 하면 Domain 로직에 영향이 없이 기능 확장이 가능해진다.

### 동기 이벤트 처리 문제

동기적으로 이벤트를 처리하게 되면 이벤트 핸들링이 오래걸리게 되션거나, 익셉션이 발생하는 경우 트랜젝션 처리와 같은 문제가 발생한다.
이를 해결하기 위해 비동기로 이벤트 처리를 구현한다.
 
### 비동기 이벤트 처리

만약 별도의 스레드를 이용해서 이벤트 핸들러를 실행하면 이벤트 발생 코드와 같은 트랜젝션에 묶을 수 없기 때문에 한 트랜젝션으로 실행해야 하는 이벤트 핸들러는 비동기로 처리해선 안된다.

RabbitMQ와 같은 메시징 큐를 이용해 비동기 이벤트를 구현한다. 이 때 많은 경우 보통 이벤트를 발생하는 주체와 이벤트 핸들러가 서로 다른 프로세스에서 동작한다.
RabbitMQ는 글로벌 트랜잭션을 지원하지만 Kafka같은 경우 지원하진 않으나, 그 대신 성능이 뛰어나다.

TODO: 이 부분은 직접 코드로 구현해봐야 이해가 빠르겠다.

## 11. CQRS(Command Query Responsibility Segregation)

시스템이 제공하는 기능은 크게 두 가지다.
- 상태를 변경
- 상태를 조회

이 때 변경은 명령(Command)로, 조회는 쿼리(Query)로 모델을 분리하는 패턴이 바로 CQRS다.

CQRS는 복잡한 Domain에 적합하다. 두 기능을 단일 모델로 처리하는 경우 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해진다.

CQRS는 그럼 DDD에 어떻게 적용할 수 있을까?

방법은 다양하다. 명령 모델과 조회 모델을 서로 다른 기술을 이용해서 구현할 수도 있고, 서로 다른 저장소를 이용하도록 구현할 수도 있다.

### 서로 다른 기술을 이용해서 구현

서로 다른 기술을 이용해서 구현하는 경우,
명령일 때는 컨트롤러 -> 응용서비스 -> Domain -> Infra -> DB 를 거치지만,
조회의 경우에는 DB -> Infra -> DTO/DAO -> 컨트롤러가 되도록 하여 응용서비스나 Domain을 거치지 않게 할 수도 있다.

이때 조회 모델과 명령 모델을 서로 다르게 구현해놓을 수도 있다.

### 서로 다른 저장소를 이용해서 구현  

명령과 조회를 할 때 서로 다른 저장소를 사용하는 방법이 있는데, 이 때는 데이터 동기화 이슈가 생긴다.
그러나 명령일 때는 트랜젝션이 주로 필요하므로 트랜젝션을 지원해주는 RDBMS를 사용하고, 조회는 성능이 좋은 메모리 기반 NoSQL을 사용하도록 할 수 있을 것이다.

그럼 이 경우 데이터 동기화는 어떻게 시킬까? 바로 이벤트에 그 해답이 있다.
명령 모델에서 상태를 변경하면 이벤트가 발생하고, 이벤트 핸들러에서 조회 모델에도 변경 내역을 반영하면 된다.

이 때 항상 동기적으로 구현할 필요도 없다. 만약 통계치를 보여주는 대쉬보드를 구현한다면 데이터가 즉시 동기화될 필요가 없으므로 비동기로 데이터를 동기화하기도 한다.
 
## Ref

DDD start! (최범균 저)
