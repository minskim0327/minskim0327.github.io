---
layout: post
title: 게임판 덮기 문제 (BOARDCOVER, 난이도 하)
category: [online-judge]
author: hyungsun
image: assets/images/JM_BOARDCOVER.png
---

## Prologue

------
종만북에 등장하는 난이도 (하)짜리 문제 중 2번째로 등장하는 BOARDCOVER 문제를 풀어보았다.

## Monologue

------

### 1. 문제

게임판 덮기 문제는 다음과 같다.

> ![]({{ site.url }}/assets/images/JM_BOARDCOVER.png)
> H*W 크기의 게임판이 있습니다. 게임판은 검은 칸과 흰 칸으로 구성된 격자 모양을 하고 있는데 이 중 모든 흰 칸을 3칸짜리 L자 모양의 블록으로 덮고 싶습니다. 이 때 블록들은 자유롭게 회전해서 놓을 수 있지만, 서로 겹치거나, 검은 칸을 덮거나, 게임판 밖으로 나가서는 안 됩니다. 위 그림은 한 게임판과 이를 덮는 방법을 보여줍니다.
>
> 게임판이 주어질 때 이를 덮는 방법의 수를 계산하는 프로그램을 작성하세요.
>
> #### 입력
>
> 력의 첫 줄에는 테스트 케이스의 수 C (C <= 30) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 2개의 정수 H, W (1 <= H,W <= 20) 가 주어집니다. 다음 H 줄에 각 W 글자로 게임판의 모양이 주어집니다. `#` 은 검은 칸, `.` 는 흰 칸을 나타냅니다. 입력에 주어지는 게임판에 있는 흰 칸의 수는 50 을 넘지 않습니다.
>
> #### 출력
>
> 한 줄에 하나씩 흰 칸을 모두 덮는 방법의 수를 출력합니다.
>

재미있어 보이는 문제다. 운 좋게도 이 문제를 해결하기 위한 실마리를 잡는 데는 그리 오래 걸리지 않았지만, 예외 처리나 중복 제거 같은 부분에서 시간을 오래 잡아 먹었다. 

문제를 해결하기 위한 키 포인트는 문제를 작게 쪼개어 생각하면서 얻게 되었다. 재귀적으로 생각했을 때, 한 블록씩 채워진 게임판을 계속 다음 싸이클로 넘겨준다면 맨 마지막에는 더 이상 채울 수 없는 때가 온다. 바로 그 경우가 블록을 채우는 한 가지 케이스를 찾은 것이라고 본 것이다.

### 2. 문제 풀이
밑의 코드는 핵심적인 부분만 따온 것이고, 주석을 포함한 전체 소스 코드는 [여기에](https://github.com/poqw/JongmanBookSolutions/blob/master/poqw/boardCover.cpp) 올려 두었다.
```cpp
unsigned int WIDTH, HEIGHT;

int getNumberOfBlanksRemained(vector<vector<char>> board) {
  int numberOfBlanks = 0;
  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      if (board[i][j] == '.') {
        numberOfBlanks++;
      }
    }
  }

  return numberOfBlanks;
}

bool isDuplicatedCase(vector<vector<char>> board, int x, int y) {
  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      if (i == y && j == x) {
        return false;
      }

      if ((board[i][j] == '.' && board[i][j + 1] == '.'
         && board[i + 1][j] == '.')
        || (board[i][j] == '.' && board[i][j + 1] == '.'
         && board[i + 1][j + 1] == '.')
        || (board[i][j] == '.'
         && board[i + 1][j] == '.' && board[i + 1][j + 1] == '.')
        || j - 1 >= 0 &&
        (board[i][j] == '.' &&
         board[i + 1][j - 1] == '.' && board[i + 1][j] == '.')) {
        return true;
      }
    }
  }

  return false;
}

int coverBoard(vector<vector<char>> board) {
  int remained = getNumberOfBlanksRemained(board);
  if (remained % 3 != 0) {
    return 0;
  }

  if (remained == 0) {
    return 1;
  }

  int result = 0;

  for (int i = 0; i < HEIGHT; i++) {
    for (int j = 0; j < WIDTH; j++) {
      if (!isDuplicatedCase(board, j, i)) {
        if (board[i][j] == '.' && board[i][j + 1] == '.'
            && board[i + 1][j] == '.') {
          board[i][j] = '#';
          board[i][j + 1] = '#';
          board[i + 1][j] = '#';
          result += coverBoard(board);
          board[i][j] = '.';
          board[i][j + 1] = '.';
          board[i + 1][j] = '.';
        }

        if (board[i][j] == '.' && board[i][j + 1] == '.'
            && board[i + 1][j + 1] == '.') {
          board[i][j] = '#';
          board[i][j + 1] = '#';
          board[i + 1][j + 1] = '#';
          result += coverBoard(board);
          board[i][j] = '.';
          board[i][j + 1] = '.';
          board[i + 1][j + 1] = '.';
        }

        if (board[i][j] == '.'
            && board[i + 1][j] == '.' && board[i + 1][j + 1] == '.') {
          board[i][j] = '#';
          board[i + 1][j] = '#';
          board[i + 1][j + 1] = '#';
          result += coverBoard(board);
          board[i][j] = '.';
          board[i + 1][j] = '.';
          board[i + 1][j + 1] = '.';
        }

        if (j - 1 >= 0 &&
            (board[i][j] == '.'
             && board[i + 1][j - 1] == '.' && board[i + 1][j] == '.')) {
          board[i][j] = '#';
          board[i + 1][j - 1] = '#';
          board[i + 1][j] = '#';
          result += coverBoard(board);
          board[i][j] = '.';
          board[i + 1][j - 1] = '.';
          board[i + 1][j] = '.';
        }
      }
    }
  }

  return result;
}
```

### 풀이

언뜻 보기에 복잡해 보이지만, 하는 일은 매우 단순하다. 사람이 보드판을 채우는 놀이를 할 때 으레 그렇듯이, 블럭이 들어갈 수 있는지 살펴보고 실컷 채운 후에 다시 블럭을 치우고 다른 경우를 찾는 것이다.

문제를 풀면서 블럭을 채울 수 있는 4가지 케이스를 처음에는 간단히 아래와 같이 생각했다. 2 x 2사이즈 정사각형으로 보드판을 순회하면 빠짐없이 L 블록을 채우는 모든 케이스를 셀 수 있다고 여겨서였다. 여기서 `?`는 `.`또는 `#`을 의미한다.
```cpp
// Case 1.
[?][.]	
[.][.]	
// Case 2.
[.][?]	
[.][.]	
// Case 3.
[.][.]	
[?][.]	
// Case 4.
[.][.]
[.][?]
```

그러나 이렇게 하게 되면 중복제거를 할 때 정말 매우매우 어렵고 복잡해 진다. 여기서 말하는 중복이란,  아래와 같은 경우를 말한다.

```cpp
// Duplication ex 1.
[.][.][.]		[#][#][.]		[#][#][#]
[.][.][.]		[#][.][.]		[#][#][#]
// Duplication ex 2. Whitch is exactly the same as Duplication ex 1.
[.][.][.]		[.][.][#]		[#][#][#]
[.][.][.]		[.][#][#]		[#][#][#]
```

이 중복은 모든 경우에 재귀 분기를 타서 발생하므로, 이를 회피하기 위해서는 좌상단에서부터 순서대로 채운다는 나름의 룰을 정해야 한다. 내가 지금 블록을 채우려고 살펴보고 있는 위치가 `(i, j)`라고 했을 때 `(i, j - 1)`까지 블록을 그릴 수 있는 경우의 수가 단 하나라도 존재한다면, 분명 지금 위치까지 도달하기 전에 룰에 의해 이미 재귀 분기를 타고 있을 것이므로 세지 말아야 한다. 이 부분은 위의 코드에서 `isDuplicatedCase`가 담당하고 있다.

그러나 위 방식처럼 케이스를 상정한 경우에는 Case 1의 예외처리가 힘들어 진다. 모든 케이스를 기준으로 해서 `(0, 0)`이 현재 보고 있는 커서의 위치인데, Case 1만 `(0, 0)`이 비어있기 때문이다. 상식적으로 블록을 채우는 로직과 이전에 채울 수 있는 블록이 있는지 검사하는 여부는 완전히 같아야 하는데 저 비어있는 공간 하나 때문에 Case 1의 로직만 복잡하게 바뀌게 된다. 나는 이 예외처리를 하는 데 실패했는데, 누군가 저런 방식으로 문제를 풀었다면 댓글로 알려주시기 바란다.

어쨌든, 문제를 쉽게 풀기 위한 결론부터 이야기하면 케이스를 다음과 같이 상정해야 한다.
```cpp
// Case 1.
[?][.][?]	
[.][.][?]	
// Case 2.
[?][.][?]	
[?][.][.]	
// Case 3.
[?][.][.]	
[?][?][.]	
// Case 4.
[?][.][.]
[?][.][?]
```
오히려 더 어려워질 것 처럼 생겼지만, 짜보면 의외로 위 풀이에서 보여지는 것처럼 코드가 간결하다. 이 케이스들에선 커서가 `(0, 1)`이고, 보다시피 모두 `.`으로 채워져 있다. 이 부분이 예외처리를 쉽게 할 수 있도록 도와준다.

내가 느끼기에 이 문제의 가장 어려운 점은 **처음부터 아래 방식으로 생각할 수 있느냐**이다. 내가 프로그래밍을 하는 데에 많이 익숙했더라면, 첫 번째 방식에서 이상한 점을 빨리 눈치챘을 것이라고 생각한다. 관련있는 데이터끼리 모으려는 개발자의 직감이나 공통된 부분끼리 묶으려고 하는 성질 같은 거랄까.... 나에게는 그게 별로 없는 것 같다. 처음 방식에서 Case 1이 Case 2, 3, 4와 완전히 다른 케이스라는 걸 인지하기까지 너무 오래 걸렸다.

### 개선점

사실 포스팅을 하는 시점에 눈에 보이는 개선점은 모두 개선을 하고 올리기 때문에 여기다가는 어떻게 개선을 했는지를 적는 게 나을 것 같다.

우선 처음 코드에서는 중복제거를 하지 않았다. 

위에서 언급한 중복 문제는 N명의 학생을 1열로 세우는 경우의 수와 같기 때문에 모든 경우의 수를 센 후에 `(쌓을 수 있는 블럭 수 N)!`로 나눠 주면 답을 구할 수 있다고 생각했다. 이 경우, 실제로 답은 맞게 나온다. 하지만 이렇게 하게 되면 엄청나게 케이스를 많이 세어 버려서, 어쩔 수 없이 중복 제거를 해주게 되었다.

또, 빈 공간의 수가 3의 배수가 아닌 경우는 일일이 세어 볼 필요가 없는데 이 역시도 리펙토링 하는 과정에서 추가했다. `getRemainBlankNumber`로 비어있는 공간의 개수를 센 뒤, 3의 배수가 아니라면 바로 0을 리턴했다.

## Epilogue

------

아직까지도 C계열 언어들에 대한 기본이 부족한 탓에, C++ 에서 2차 배열을 다루는 게 너무 짜증났다. `BOARD[height][width]`를 어떻게든 고수하려고 하다가, 결국엔 `vector`를 쓰는 것으로 혼자 합의를 봤다. 하지만 짜증났던 이유는 덮었던 블록을 치워서 재 사용하는 게 아니라, 새로운 보드판을 계속 다음 번 싸이클로 넘기려고 했었기 때문이라, 지금 와서 생각해보니 `BOARD[height][width]`로 했어도 별 문제 없을 것 같다는 생각이 든다. 

여하튼, 별 것 아닌 문제로 시간을 너무 많이 쏟았다. 시간을 가장 많이 잡아 먹은 부분은 디버깅이다. 어처구니 없는 실수들을 자꾸 저질렀다. 이를 테면 for 루프안에서 height 와 width를 헷갈린다 던지 하는 식으로 말이다. 중복 제거가 제대로 되지 않아 디버깅하는 데도 시간이 오래 걸렸다. 이런 경우에는 디버깅을 해도 얻는 게 없기 때문에, 애초부터 만들지 않는 게 최선이라는 생각이 든다. 