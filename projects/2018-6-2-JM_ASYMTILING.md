---
layout: post
title: 비대칭 타일링 문제 (ASYMTILING, 난이도 하)
category: [online-judge]
author: hyungsun
image: assets/images/JM_ASYMTILING_1.png
---

## Prologue

------
종만북에 등장하는 난이도 (하)짜리 문제 중 6번째로 등장하는 ASYMTILING 문제를 풀어보았다. 

## Monologue

------

### 1. 문제

문제는 다음과 같다.

> #### 문제
>
> ![]({{ site.url }}/assets/images/JM_ASYMTILING_1.png)
>
> 그림과 같이 2 * n 크기의 직사각형을 2 * 1 크기의 타일로 채우려고 합니다. 타일들은 서로 겹쳐서는 안 되고, 90도로 회전해서 쓸 수 있습니다. 단 이 타일링 방법은 좌우 대칭이어서는 안 됩니다. 위 그림은 2 * 5 크기의 직사각형을 채우는 비대칭 타일링 방법 6가지를 보여줍니다. 다음의 2가지는 좌우대칭이기 때문에 세지 않습니다.
>
> ![]({{ site.url }}/assets/images/JM_ASYMTILING_2.png)
>
> n 이 주어질 때 가능한 비대칭 타일링 방법의 수를 계산하는 프로그램을 작성하세요. 방법의 수는 매우 클 수 있으므로, 1,000,000,007 로 나눈 나머지를 출력합니다.
>
> #### 입력
>
> 입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 50) 가 주어집니다. 그 후 각 줄에 사각형의 너비 n (1 <= n <= 100) 이 주어집니다.
>
> #### 출력
>
> 각 테스트 케이스마다 한 줄에 비대칭 타일링 방법의 수를 1,000,000,007 로 나눈 나머지를 출력합니다.

문제를 풀기 위한 아이디어는 깊게 고민하지 않고 금방 도출해 낼 수 있었다. 비대칭 타일링 방법의 수는 모든 타일링 방법의 수에서 대칭 타일링 방법의 수를 빼면 되기 때문이다. 물론 대칭 타일링 방법의 수를 구하는 게 어렵다면 다른 방식을 생각해 봐야 겠지만, 이번 문제에서는 아주 쉽게 구할 수 있다. 

가령 사각형의 너비가 7인 보드 판이 주어진다고 하자. 그리고 DP로 접근할 것이기 때문에 나는 각 너비 별로 타일링 방법의 수를 알고 있다고 가정한다. 즉, 너비가 n일 때 방법의 수는 P(n)으로, 난 이미 구해놓은 상태인 것이다.

이 때 좌우 대칭인 타일링 방법의 수는 앞서 언급했듯 P(7) - 대칭 타일링 방법의 수 인데, 이 대칭 타일링 방법의 수는 P(3)이다. 가운데 타일이 하나 놓여져 있다고 했을 때, 왼쪽 3칸을 어떻게 채우든지 오른쪽을 똑같이 채우면 되기 때문이다. 따라서 n이 홀수일 때 비대칭 타일링 방법의 수는 P(n) - P(n/2)로 일반화할 수 있다.

n이 짝수인 경우 역시 마찬가지다. 가운데에 2개의 뉘여진 블록을 놓는 경우와 2개가 세워진 블록을 놓는 경우의 수를 빼주면 된다. 고민해 볼 것도 없이, 2개가 뉘여져 있다면 타일링 방법의 수는 P(n/2 -1)일 것이고, 세워져 있다면 P(n/2)일 것이다.

즉, 위 아이디어를 종합해서 다음과 같은 점화식을 만들어 낼 수 있다(비대칭 타일링 방법의 수를 S(n)이라 하자).

n이 짝수인 경우, S(n) = P(n) - P(n/2) - P(n/2 - 1)

n이 홀수인 경우, S(n) = P(n) - P(n/2)

P(n)에 대한 점화식을 세우는 것도 간단하다. 맨 앞부터 차례대로 채운다고 했을 때, 가장 마지막 한 칸을 남기고서 타일링을 할 수 있는 방법의 수는 P(n-1)이다. 마지막 한 칸만은 어떻게 놓든 단 한 가지 경우밖에 없기 때문이다. 마지막 두 칸을 남긴 경우를 생각해 보자. 2개의 블록이 모두 가로로 뉘여져 있는 경우 방법의 수는 P(n-2)다. 마지막 2개가 모두 뉘여져 있다면 앞서 카운팅했던 경우와는 중복이 단 한 개도 나오지 않는다. 그런데 만약 2개가 세워져 있는 경우라면 P(n-1)에서 이미 카운팅을 모조리 했으므로 더 이상 셀 필요가 없다. 즉, 타일링을 하기 위한 방법의 수는 신기하게도 피보나치 점화식을 따른다.

P(n) = P(n-1) + P(n-2)

이제 아이디어가 슈도코드급으로 굳어졌으니, 구현만 하면 되는 일이다.

### 2. 아이디어 구현
아래 코드는 핵심적인 부분만 따온 것이고, 전체 소스 코드는 [여기에](https://github.com/poqw/JongmanBookSolutions/blob/master/poqw/asymtiling.cpp) 올려 두었다.
```cpp
int cache[101];
const int DIVIDER = 1000000007;

/**
 * Fill cache with fibonacci sequence.
 * @param n Index of how many will be filled to the cache.
 */
int cacheFibonacci(int n) {
  if (cache[n] != -1) {
    return cache[n];
  }

  cache[n] = (cacheFibonacci(n - 1) + cacheFibonacci(n - 2)) % DIVIDER;
  return cache[n];
}

int getNumberOfAsymtylingCases(int n) {
  cacheFibonacci(n);
  if (n < 3) {
    return 0;
  }

  int result;
  if (n % 2 == 0) {
    result = cache[n] + DIVIDER - (cache[n / 2] + cache[n / 2 - 1]) % DIVIDER;
  } else {
    result = cache[n] - cache[n / 2];  
  }

  return result % DIVIDER;
}
```

### 3. 풀이

사실, 나에게 이 문제의 관건은 문제를 푸는 아이디어를 떠올릴 수 있느냐 보다는 오버플로우를 핸들링할 수 있느냐였다. 이렇게 오버플로우를 핸들링해야하는 문제는 처음이라, 값이 계속 엉뚱하게 나오는 바람에 아이디어가 틀린 건 아닌지 점검하느라 아까운 시간을 보냈다.

이 문제에서는 n 숫자가 작을 때는 상관이 없지만, 숫자가 조금만 커져도 int 범위를 가뿐히 넘는다. 이걸 처리하기 위한 힌트는 문제에서 제시한 `DIVIDER`(1,000,000,007)에 있다. 이 값은 int 범위의 절반(21억)보다 조금 안되기 때문에, 충분히 크지만 이 값보다는 작은 두 값을 더해도 오버플로우가 나지 않음을 보장할 수 있다. 즉 캐싱을 할 때 항상 `DIVIDER` 로 나누어 주어도 문제에서 구하고자 하는 답을 얻기에 충분하다는 것이다. 

마지막 

`result = cache[n] + DIVIDER - (cache[n / 2] + cache[n / 2 - 1]) % DIVIDER;`

이 녀석이 관건인데, 만약 `cache[n]` 이 10억 조금 넘어서 아주 작은 값이 나온 상태라면,  `cache[n / 2]` 근처 값들은  5억보다 훨씬 안될 것이다. 즉 `(cache[n / 2] + cache[n / 2 - 1]) % DIVIDER`  이 녀석이 `cache[n]` 보다 커지는 경우가 생긴다. 그래서 `cache[n]`에 `DIVIDER` 를 더해주고 시작한다. 어차피 문제에서는 `DIVIDER` 로 나눈 나머지가 궁금한 것이기 때문에 `DIVIDER` 를 더해줘도 답을 도출하는 데는 지장이 없다. 말은 간단하게 하지만 사실 이 부분도 한참 생각했다.

### 개선점

코드가 워낙 간단해서 개선점을 찾지 못했다. 다만 문제의 의도인 DP보다는 캐싱으로 푼 점이 마음에 걸린다. 이거 한 끝 차이 아닌가...?


## Epilogue

------

CLion의 라이센스가 만료되어서 짜증이 난단 내용을 과거 포스팅에서 쓴 적이 있는데, 의외로 제트브레인에서 30분 정도는 라이센스 없이 쓰게 해준다는 걸 알았다. 그래서 아이디어를 구체화 시킨 뒤 구현은 30분 내로 하는 것이 자연스레 목표아닌 목표가 되었다. 본인처럼 알고리즘만을 공부하기 위해 쓰는 것이라면, 이런 방식이 어쩌면 더 좋을 수도 있겠다.