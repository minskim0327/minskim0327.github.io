---
layout: post
title: DDD(Domain Driven Design) Intro  
category: [ddd, architecture, design, software, domain]
author: hyungsun
image: assets/images/ddd_1.png
---
## DDD 시리즈
1. [DDD Intro]({{site.url}}/ddd_1)

## Domain Driven Design
Domain Driven Design(이하 DDD)은 **도메인**에 집중하여 소프트웨어 디자인을 하는 방법론을 의미한다. 여기서 말하는 도메인이란 소프트웨어가 풀어야 할 핵심 문제 영역이다.
가령 온라인 채팅 서비스를 만들어 달라는 사람들과 개발자가 일을 같이 하게 된다면, 온라인 채팅 서비스 자체가 바로 도메인에 해당한다.

도메인에 집중한다라는 이야기는 도메인을 우리가 집중할 수 있도록 잘게 문제 영역을 분할한다는 의미를 내포하며,
나아가 이들 사이의 관계를 직관적으로 이해하고 있어야 한다는 문맥으로 통한다.

## 도메인을 나누는 기준
안타깝게도 집중할 수 있도록 나눈다는 말은 여전히 불명확하다. DDD에서는 이를 명확하게 하기 위해 도메인 영역을 나눌 목적으로 **요구사항**부터 정리해야 한다고 말한다.
예로, 온라인 채팅 서비스의 요구사항을 들여다보자.
- **사용자**는 회원 가입을 할 수 있어야 한다.
- 로그인을 한 사용자만이 서비스를 이용할 수 있다.
- 사용자 끼리는 아이디 검색을 통해 서로 **친구**를 맺을 수 있다.
- 친구 끼리는 **채팅방**을 통해 서로 실시간으로 **대화**할 수 있다.
- 친구 끼리 대화할 때 채팅방에서 대화를 보고 있지 않은 온라인 친구(들)에게 **알림**을 보내주어야 한다.
- 친구 목록에서 한 명 혹은 여러 명을 선택해 채팅방을 구성할 수 있어야 한다.

영역을 나누기 위한 좋은 팁 중 하나는 요구사항 명세로부터 핵심 키워드를 뽑아내는 것이다. 위 내용에서는 '사용', '친구', '대화(채팅)', '채팅방', '알림'등이 바로 핵심 키워드에 해당한다.
위와 같이 핵심 키워드를 뽑아냈다면 이를 묶어서 다음과 같이 영역 분할을 할 수 있다.
- 사용자: 회원가입, 로그인 등을 처리
- 친구: 대화할 상대방
- 채팅: 실시간 채팅 처리
- 채팅방: 여러 명이서 대화할 수 있는 공간
- 알림: 대화 알림 처리

위 내용을 개념적으로 표현해 본다면 아래와 같을 것이다. 
서로 직접적으로 관련이 있을 법한 도메인끼리 연결시켜 놓아 영역 간의 관계를 표현해 주었다.
이렇게 개념적으로 도메인을 표현한 것을 **도메인 모델**이라고 한다.
<p align="center">
  <img src="{{ site.url }}/assets/images/ddd_2.png">
</p>

> NOTE: 혹시 도메인 영역을 잘못 나누진 않았을까 너무 걱정하지 않아도 좋다. 그 이유는 십중팔구 이미 잘못 나누었을 공산이 크기 때문이다.
> 처음부터 완벽할 수 없다는 사실을 자연스레 받아들이자.
> 개발자가 시간의 흐름에 따라 도메인에 대해 더 잘 이해하게 되면서 도메인 모델을 지속적으로 개선해 나가는 모습은 오히려 반겨야 할 일이다.

## Entity & Value
위와 같이 나누었다고 해서 바로 코딩을 시작할 수 있는 건 아니다. DDD에서는 Entity와 Value단위까지 쪼갤 수 있어야 비로소 도메인에 집중할 수 있다고 본다.

여기서 말하는 Entity는 고유한 식별자를 갖는 존재를 의미한다. 각 Entity는 서로 다른 식별자를 갖기 때문에 서로 다른 Entity를 비교할 때 식별자가 같다면 Entity 내부의 다른 값을 살펴보지 않아도
두 Entity는 같다고 보장할 수 있다. Entity는 또한 자신의 **라이프사이클**을 가지며, 도메인 모델의 데이터를 포함하고 해당 **데이터와 관련된 기능**을 함께 제공한다.
예를 들어, 사용자는 사용자의 ID를 가짐으로써 서로를 구별하고 관계를 맺을 수 있는데 이는 사용자가 Entity임을 의미한다. 
사용자 엔티티는 사용자와 관련된 기능인 on/off라인 상태 변경, 로그인 등의 기능들을 제공할 책임을 지닌다.

Value는 반대로 식별자를 갖지 않고, 도메인 객체의 속성을 표현할 때 사용된다. 서로 같은 Value인지 검사해야 한다면 내부적으로 모든 값이 같은지 비교해야 한다.
Value는 또한 불변이다. 만약 Value를 수정해야 한다면 setter를 통해 내부 값을 수정하는 것이 아니라 완전히 새로운 객체에 값들을 새로 담아 내려주어야 함을 뜻한다.
Value는 Entity의 속성으로 사용될 뿐만 아니라 다른 Value타입의 속성으로도 사용될 수 있다.
예를 들어, offline인지 online인지 나타내는 사용자의 상태는 Value이다.
 
위에서 만들었던 도메인 모델을 다시 Entity와 Value로 표현하면 아래와 같다.
<p align="center">
  <img src="{{ site.url }}/assets/images/ddd_3.png">
</p>
 
위 그림에서 id를 가지고 있는 User와 ChattingRoom이 바로 Entity가 되고 나머진 Value가 된다.

## 도메인 아키텍쳐
전형적인 계층화 패턴을 적용한 소프트웨어 아키텍쳐는 보통 4개의 Layer로 소프트웨어의 계층을 나눌 수 있다. 
- 표현 계층 (Presentation): 사용자와 맞닿아 있는 영역으로, 소프트웨어를 표현한다.
- 어플리케이션 계층 (Application): 도메인과 표현계층을 이어주는 매개체다. 사용자의 요청을 처리하고 응답한다.
- 도메인 계층 (Domain): 소프트웨어의 핵심 아이디어를 담고 있다. Business Logic Layer라고도 한다.
- 인프라 계층 (Infrastructure): Database와 같은 데이터 처리 인프라를 담고 있다.
  
DDD도 이와 크게 다르진 않다. 다만 의존성 관계에서 차이가 나타난다.
<p align="center">
  <img src="{{ site.url }}/assets/images/ddd_4.png">
</p>

위 그림에서 알 수 있듯이, 도메인 계층의 의존성을 [DIP](https://en.wikipedia.org/wiki/Dependency_inversion_principle)(Dependency Inversion Principle)를 이용해 역전시킨 것이 DDD와 다른 디자인의 차이점이다.
이 차이점으로부터 DDD가 가져가는 이득은 다음 2가지다.
1. 도메인 로직을 테스트하기가 쉽다.
2. 구현 방식을 변경하기 쉽다.

도메인 레이어가 다른 계층에 의존하지 않으므로 테스트하기가 쉬워진다. 가령 인프라 계층에 의존하는 도메인 로직이라면 직접 테스트 디비를 생성하고,
디비안에 테스트 데이터를 넣고 도메인 로직을 실행시키는 방식으로 테스트를 진행해야 하지만, 의존성을 역전 시킨 경우라면 Mocking으로 간단하게 해결이 가능하다.
또, RDBMS를 쓰다가 NoSQL을 쓰도록 인프라 계층의 구현 방식을 바꾸고 싶은 경우에도 인터페이스만 준수한다면 쉽게 변경할 수 있다. 

## 끝으로
이 글에서는 DDD의 간략한 개요를 다루었다. 다음 글에서는 위에서 작성해 보았던 채팅 서비스의 도메인 모델 개선과, 각 레이어 중 도메인 레이어에 대해서 더 자세히 알아볼 것이다.
