---
layout: post
title: 숫자 게임 문제 (NUMBERGAME, 난이도 하)
category: [online-judge]
author: hyungsun
image:
---

## Prologue

------
종만북에 등장하는 난이도 (하)짜리 문제 중 7번째로 등장하는 NUMBERGAME 문제를 풀어보았다. 

## Monologue

------

### 1. 문제

문제는 다음과 같다.

> #### 문제
>
> n개의 정수를 일렬로 늘어놓은 게임판을 가지고 현우와 서하가 게임을 합니다. 게임은 현우부터 시작해서 번갈아가며 진행하며, 각 참가자는 자기 차례마다 두 가지 일 중 하나를 할 수 있습니다.
>
> - 게임판의 왼쪽 끝에 있는 숫자나 오른쪽 끝에 있는 숫자 중 하나를 택해 가져갑니다. 가져간 숫자는 게임판에서 지워집니다.
> - 게임판에 두 개 이상의 숫자가 있을 경우, 왼쪽 끝에서 2개, 혹은 오른쪽 끝에서 2개를 지웁니다.
>
> 게임은 모든 숫자가 다 없어졌을 때 끝나며, 각 사람의 점수는 자신이 가져간 숫자들의 합입니다. 현우와 서하는 점수가 더 낮은 쪽이 점수 높은 쪽에 한 점 차이마다 백 원씩 주기로 내기를 했습니다. 두 사람 모두 최선을 다할 때, 두 사람의 최종 점수 차이는 얼마일까요?
>
> #### 입력
>
> 입력의 첫 줄에는 테스트 케이스의 수 C (C <= 50) 이 주어집니다. 각 테스트 케이스의 첫 줄에는 게임판의 길이 n (1 <= n <= 50) 이 주어지며, 그 다음 줄에 n 개의 정수로 게임판의 숫자들이 순서대로 주어집니다. 각 숫자는 -1,000 에서 1,000 사이의 정수입니다.
>
> #### 출력
>
> 각 테스트 케이스마다 한 줄로, 두 사람이 최선을 다했을 때 현우가 서하보다 몇 점 더 얻을 수 있는지를 출력합니다.

입력 예제가 도무지 이해가 안가서 다시 천천히 문제를 읽어보니, 자신의 턴에 할 수 있는 일 중 2번째가 2개의 숫자를 자신이 가져가는 것이 아니라 그냥 지우는 것 뿐이라는 걸 깨달았다. 역시 문제는 차근차근 읽어야 한다.

문제에서 주어진 예제 입력부터 살펴보고 가자. 입력은 다음과 같고, 점수가 높은 쪽이 승리다.

```java
-1000 -1000 -3 -1000 -1000 
100 -1000 -1000 100 -1000 -1000 
7 -5 8 5 1 -4 -8 6 7 9 
```

맨 처음 경우부터 살펴보겠다. `[]`안의 숫자들은 보드판의 상태를 나타내며, 시나리오는 다음과 같다.

```java
1. 보드: [-1000, -1000, -3, -1000, -1000]
2. 현우는 일단 -1000을 자신이 가져가는 게 마음에 안들기 때문에, 왼쪽에서 2개를 지운다.
   보드: [-3, -1000, -1000]
3. 서하는 현재 상태에서 최선의 수를 생각해 봤을 때, 현우에게 -3을 주는 것보다 -1000을 주는 편이 
   훨씬 흐뭇하기 때문에 왼쪽에서 2개를 지운다. 
   보드: [-1000]
4. 현우는 눈물을 머금고 -1000을 가져간뒤, 서하에게 10만원을 삥뜯긴다. 
   보드: []
```

두 번째 경우도 크게 다르지 않다. 시나리오는 다음과 같다.

```java
1. 보드: [100, -1000, -1000, 100, -1000, -1000]
2. 현우는 일단 뒤도 안돌아보고 잽싸게 100을 가져가는 게 현재 상태에서 최선의 수다.
   보드: [-1000, -1000, 100, -1000, -1000]
3. 서하는 왼쪽, 오른쪽 어느 쪽을 보아도 -1000을 뽑을 수 밖에 없기 때문에, 별 수 없이 숫자를 2개 
   지우는 쪽을 택한다. 
   보드: [100, -1000, -1000]
4. 현우는 똑똑하게도 100을 챙기는게 아니라, 왼쪽에서 2개를 지워 서하를 골탕먹이는 방법을 택한다.
   보드: [-1000]
5. 서하는 눈물을 머금고 -1000을 챙긴 뒤, 현우에게 11만원을 삥뜯긴다.
   보드: []
```

마지막 3번째 경우는 글로 적기엔 다소 복잡하기 때문에 생략하겠다. 지금까지 등장했던 시나리오를 기반으로 점화식을 먼저 세워보자.

지금 당장 최대의 이익을 얻기 보다, 상대방의 수까지 생각해야 하기 때문에 점화식을 다음과 같이 세울 수 있다.

```java
play(left, right) = max(
	// 맨 왼쪽을 가져가는 경우.
	board[left] - play(left + 1, right),
	// 맨 오른쪽을 가져가는 경우.
	board[right] - play(left, right - 1),
	// 왼쪽 2개를 지우는 경우.
	-play(left + 2, right),
	// 오른쪽 2개를 지우는 경우.
	-play(left, right - 2)
  )
```

문제는 이렇게 계산할 경우 경우의 수가 너무 많아지기 때문에 DP를 이용해야 한다는 것이다. 캐싱을 하기 위해선 입력의 최대 개수는 50개 이므로 50 x 50 만큼의 공간이 필요하다. 가로 축은 왼쪽부터 지워진 개수, 세로 축은 오른쪽부터 지워진 개수라고 생각하면 편하다. 즉 5개의 인풋이 주어졌다면, 가로로 2, 세로로 3 떨어진 칸에 들어갈 놈은 왼쪽에서 2개, 오른쪽에서 3개가 지워진 보드 판에서 얻을 수 있는 `play(left, right)`이다. 

... 라고 생각하고 구현하다 보니 복잡해지는 것 같아서, 그냥 충분히 공간 마련해 놓고 곂치지만 않으면 된다는 생각으로. `cache`에 곧바로 때려 박았다. 이 부분은 코드에서 확인 가능하다.

### 2. 아이디어 구현
아래 코드는 핵심적인 부분만 따온 것이고, 전체 소스 코드는 [여기에](https://github.com/poqw/JongmanBookSolutions/blob/master/poqw/NumberGame.java) 올려 두었다. 여태까지 C++로 풀다가, 비루하게도 돈이 없는 나로선 CLion 라이센스 정책이 정말 정말 짜증이 나서 그냥 java로 풀기로 했다. 알고리즘 푸는 거야 결국엔 나중에 취업에 도움이 될 거란 기대도 없잖아 있기 때문에, 내가 사랑하는 kotlin 대신 java를 선택했다. 조금 구글링해 본 결과 kotlin은 대부분 지원을 안하기 때문이렸다.... 심지어 현 시점 구름 IDE에서도 컴파일 환경을 준비 중이다.
```cpp
  private static final int MAX_BOARD_SIZE = 50;
  private static final int EMPTY = -987654321;
  private static int[] board = new int[MAX_BOARD_SIZE];
  private static int[][] cache = new int[MAX_BOARD_SIZE][MAX_BOARD_SIZE];

  private static int play(int left, int right) {
    if (left > right) {
      return 0;
    }

    int result = cache[left][right];
    if (result != EMPTY) {
      return result;
    }

    // Case 1. Pick left.
    int firstCase = board[left] - play(left + 1, right);

    // Case 2. Pick right.
    int secondCase = board[right] - play(left, right - 1);

    if (right - left < 1) {
      cache[left][right] = max(firstCase, secondCase);
      return cache[left][right];
    }

    // Case 3. Erase 2 of left.
    int thirdCase = -play(left + 2, right);

    // Case 4. Erase 2 of right.
    int fourthCase = -play(left, right - 2);

    cache[left][right] = max(firstCase, secondCase, thirdCase, fourthCase);
    return cache[left][right];
  }

  private static int max(int... args) {
    if (args.length < 1) {
      throw new IndexOutOfBoundsException("Invalid bound size: " + args.length);
    }

    int result = args[0];
    for (int i = 1; i < args.length; i++) {
      result = Math.max(result, args[i]);
    }

    return result;
  }
}
```

### 3. 풀이

본인은 직접 책을 구매해서 책에서 문제를 보고 풀고 있는데, 이번에는 오타가 있었다. 그것도 아주 치명적인 오타가.

결론부터 말하자면 **알고리즘 문제해결전략 8쇄 발행본에서는 p.341의 예제 출력 마지막이 7 이 아니라 9로 찍혀있다**. 이는 명백하게 오타이고, 나를 무려 40분 가량 헤매게 만들었다. 내 아까운 시간과 정신적인 스트래스 어떡할거야.

오타라고 확신하는 이유는, 이 책의 [홈페이지](https://algospot.com/judge/problem/read/NUMBERGAME) 라고 되어있는 곳에서 온라인 저지를 받았기 때문이다. 내 코드는 정답으로 나왔다. 젠장!

어쨌든 각설하고, 의외로 고생했던 부분은 다름아닌 기저사례를 핸들링 하는 곳이었다. 

```java
if (left > right) {
  return 0;
}
```

처음에는 아무 생각없이 `EMPTY` 를 리턴하게 했다. 그렇게 하면 `max()` 에서 걸러질 것이라 생각한 건데, 사실 기저 사례에서는 게임이 끝난 것이므로 이전 결과에 변화가 없어야 하므로 0이어야 한다.

### 개선점

매번 개선점을 적으려고 할 때마다 할 말이 없어서 죽겠다. 그냥 이 카테고리는 이 포스팅을 마지막으로 없애버려야겠다. ~~내 블로그니 내 맘이다. 하하핳~~


## Epilogue

------

사실 알고리즘 문제를 java로 풀어본 것은 처음인데, 역시 친숙한 언어가 문제를 풀기에도 수월한 듯 하다. 굳이 싫어하는 C계열 언어를 쓰기 보단, 성능이 좀 떨어져도 문제를 맞춰버릴 정도로 잘해버리면 그만 아닌가. 그런고로 앞으로는 java로 문제를 풀 예정이다. CLion이 유료만 아니었어도....