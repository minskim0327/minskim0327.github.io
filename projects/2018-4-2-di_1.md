---
layout: post
title: DI 첫 번째, Dependency Injection에 관하여
category: [dependency-injection, dagger2]
author: hyungsun
image:
---


## Index
---
- [DI 첫 번째, Dependency Injection에 관하여]({{site.url}}/di_1)
- [DI 두 번째, Dependency Injection 시작하기]({{site.url}}/di_2)

## Prologue
---
의존성 주입(Dependency Injection, DI)을 처음 접했을 때는 정말 **멘탈이 박살났었다**. [Dagger2](https://github.com/google/dagger)로 처음 DI를 써보았는데, 그 자세하다는 영문판 [위키피디아](https://en.wikipedia.org/wiki/Dependency_injection)나 [Dagger2 Doc](https://google.github.io/dagger/users-guide)을 읽어봐도 도무지 이해가 가질 않았다. 어쨌든 내가 참여하고 있는 프로젝트에 기존에 이미 작성되어 있는 코드가 있었고, 보고 따라하면서 어찌어찌 돌아가게끔은 구현은 했다. 물론 원리나 철학은 전혀 이해하지 못한 채로 말이다. 원래 '뭔지 몰라도 돌아가기만 하면 된다'는 좋지 않은 습관이 있었는데, 좋은 개발자가 되기 위해서는 그러면 안된다는 것을 알았으므로 이 참에 내가 놓쳤던 부분들에 대해서 정리를 하려 한다.

## Monologue
---
### 1. Dependency Injection
Dependency Injection은 어느 프로그래밍 언어에도 적용할 수 있는 개념이다. **결국은 [디자인 패턴](https://en.wikipedia.org/wiki/Software_design_pattern)이기 때문**이다. 이보다 조금 더 상위의 개념이 바로 Inversion of Control, 즉 제어 역전이라는 것인데 쉽게 말하자면 class는 외부로부터 configured되어야 한다는 것이다. 여기에 관해선 글을 읽다보면 자연스레 이해가 될 것이다.

일반적으로 java의 class는 외부 클래스에 의존적이다. 이는 객체 지향이라는 본연의 성질로부터 비롯된 것이므로 거의 필연적으로 발생한다. 예를 들어 A라는 클래스가 B의 인스턴스를 사용한다면 **A는 B에 의존하고 있다**고 말할 수 있는데, 이는 java 프로젝트에서 굉장히 흔하게 볼 수 있는 패턴이다. 대표적으로 A가 우리가 구현한 service이고 B가 logger라고 생각해보자. A를 로깅(혹은 디버깅) 하기위해 `logger.info()`를 사용할 것이지 않은가? 

여기에 `Logger class` 가 `static`인 경우가 있지 않겠냐고 반문해 볼 수 있겠다. `static`이라면 `new`를 쓰지 않아도 되니 인스턴스를 사용한 것이 아니라는 것이 그 논거다. 그 말 그대로, 아래 클래스에서는 `new` 키워드가 단 한번도 등장하지 않았다.

```java
import java.util.logging.Logger;

public class MyService {

    private final static Logger logger;

    public MyService(Logger logger) {
        this.logger = logger;
    }
    
    public void someMethodShouldBeLogged() {
        logger.info("new가 없으니, MyService는 Logger에 의존하지 않아요!")      
    }
}
```

맞는 말이다. 모든 자바 클래스들이 다른 클래스로부터 분리되어 있고, 이는 곧 재사용성과 test 용이성을 높이기 때문에 정말 이상적인 상황이라고 볼 수 있다. 하지만 문제는 **모든 클래스를 `static`하게 만드는 것이 불가능하다**는 것에 있다. 당장에 `MyService`를 다른 곳에서 가져다 쓴다고 생각해보자. `new`가 필요할 것이다. `MyService` 역시 `static`으로 만들 수 있을까? `MyService`가 동작 중인지와 같은 상태를 저장해야 하는 경우에 과연 그것이 가능할까?

### 2. DI는 어떻게 동작하나

사실, `static`을 이용한 예시는 적절하지 못하다. `static`은 나름대로 그 쓰임새와 이유가 명확하기 때문에 모든 `class`를 `static`하게 만든다는 것은 말도 안되는 일이기 때문이다. 그러니 중요한 것은 지금부터다.

DI가 왜 필요한지 이해하기 위해 아주 간단히, 다음과 같은 클래스가 있다고 하자.

```java
public class MyClass {
    private AnotherClass anotherClass;

    public MyClass() {
        this.anotherClass = new AnotherClass("코드뭉치");
    }
}
```

`AnotherClass`를 클래스 내부에서 configure했으므로 `MyClass`는 `AnotherClass`에 의존성을 지닌다. 이는 곧 `AnotherClass`가 변경되면 높은 확률로 `MyClass`역시 변경해야 한다는 의미이다(지금은 `String`을 인자로 받지만 `Integer`을 받는 클래스로 바뀌었다고 생각해보자). 뭐 `MyClass`하나 정도는 가뿐히 수정하고 넘어갈 수 있다고 생각할 수 있을지 모르겠다. 그런데 `MyClass2`, `MyClass3`, `MyClass4`, ... 처럼 `AnotherClass`를 사용하는 클래스가 상당히 많다면? 상상만 해도 끔찍한 지옥이 펼쳐질 것이다. 수정하면서도 다른 걸 또 수정해야 할 게 생기는 '연쇄변경지옥' 말이다.

그래서 사람들은 이를 회피하기 위해 다음과 같이 하기로 한다.

```java
public class MyClass {

    private AnotherClass anotherClass;

    public MyClass(AnotherClass anotherClass) {
        this.anotherClass = anotherClass;
    }
}
```

`anotherClass` 를 더 이상 `MyClass`에서 configure하지 않고, 생성자의 인자로 받아버리는 것이다. **'이를 의존성이 주입되었다'** 혹은 **'제어가 역전되었다'**라고 표현한다. 서로 의존하던 관계를 끊어내 디커플링한 것이다. 실제로 `"코드뭉치"`라는 인자로 configure된 `anotherClass`를 받아야 한다는 사실을 더 이상 `MyClass`가 알 필요가 없게 되었다(서로를 알 필요가 없다는 말은 더 이상 서로 의존하지 않는다는 것이다). 생각보다 쉽지 않은가? 의존성 주입이 동작하는 원리는 이게 전부다. 외부에서 의존성을 주입해 준다는 것. 이렇게 의존성이 강한 두 클래스를 디커플링하게 되면 위 static예시에서 언급했던 두 가지 이점(**코드 재사용성**, **Test 용이성**)을 얻을 수 있다. 

하지만 클래스간의 관계가 복잡하게 얽혀있는 상황에서 저런 의존성들을 전부 외부에서 주입해 준다는 것은 쉽지 않은 일이다. 그래서 프레임 워크를 사용하는 것인데, 이 프레임 워크들이 동작하는 방식은 간단히 다음 절차를 따른다(고 생각된다, 이 부분은 직접 나중에 프레임워크 코드를 보고 변경될 수도 있다).

1. 각 클래스마다 Annotation 이나 xml등을 통해 정의된 의존성들의 배열을 만든다.

2. 모든 의존관계를 파악했다면 외부에서 주입되어서 사용되도록 코드를 제너레이팅한다.

   클래스가 사용되는 순간에 만들어 놓은 의존성 배열을 검사해서, 인스턴스가 없다면 (`Provider`의 `get()` 등을 이용해)만들어 주고 인스턴스가 이미 만들어져 있다면 그냥 리턴한다(이 부분은 Singleton과 비슷하다). 

개발자 입장에서의 결론부터 이야기 하자면, 이미 외부에서 의존성이 있다고 명시된 class들에 대한 instance들을 전부 만들어 놓았으므로 **사용하려는 instance가 런타임에는 객체 주입이 보장될 것**이라고 믿고 코딩하면 된다. 인스턴스가 언제 생성되고, 생명주기가 어떻게 되는지는 DI프레임워크가 전부 알아서 해주기 때문에 전혀 알 필요가 없는 것이다.

### 3. Dependency Injection의 사용

[JCP](https://www.jcp.org/en/home/index)에서는 [JSR330](https://www.jcp.org/en/jsr/detail?id=330)에 Dependency Injection에 대한 명세를 정의했다. 뭐 JCP니 JSR이니 하는 애들은 알 필요까진 없고, 얘네들이 무엇을 어떻게 정해놓았느냐가 중요하다.  Dependency Injection을 가능케 해주는 대표적인 프레임 워크([Dagger](https://github.com/google/dagger), [Guice](https://github.com/google/guice), [Spring](https://projects.spring.io/spring-framework/) 등)들이 이 명세를 따르기 때문이다.

Annotation을 사용해서 Dependency Injection을 해주는 다음 예시를 보자.

```java
public class Car {
    // Injectable constructor.
    @Inject 
    public Car(Engine engine) { ... }

    // Injectable field.
    @Inject 
    private Provider<Seat> seatProvider;

    // Injectable package-private method.
    @Inject 
    void install(Windshield windshield, Trunk trunk) { ... }
}
```

`@Inject` 라는 어노테이션 덕분에 런타임에는 인스턴스의 주입이 보장된다. 물론 어노테이션만 써준다고 마법처럼 인젝션이 일어나는 것은 아니고, 앞서 이야기한 DI Framework를 써야 한다.  

위 예시에서 보여주듯이 의존성 주입이 일어날 수 있는 방법은 아래 3가지다. 그리고 보통은 클래스 하나에 저렇게 3가지를 동시에 사용하지 않는다는 점 주의 바란다. 

1. 생성자 주입

   `Engine`의 주입이 일어났다.

2. 필드 주입

   `Provider<Seat>`의 주입이 일어났다.

3. 메소드 주입

   `Windshield`, `Trunk`의 주입이 일어났다.

JSP330에 위 순서대로 주입이 된어야 한다는 명세가 있으므로, 일반적으로 이 3가지 방식이 동시에 주입되고 있는 상황이라면 생성자 주입이 가장 먼저, 필드 주입이 두 번째, 메소드 주입이 가장 마지막으로 실행된다. 이 순서 때문인지는 몰라도, 동시에 여러개를 쓰든 한 가지 방식만을 쓰든 **생성자 주입이 가장 권장된다**. (얼마 되진 않지만)경험해본 바로는 생성자 주입이나 필드 주입같은 경우에는 실제 코드에서 자주 사용되는 것 같았는데, 메소드 주입은 단 한 번도 보지 못했다. 사용법이 까다롭기도 하고 권장되는 방법도 아니기 때문이 아닐까 싶다. 사용법이 까다로운 예로, `@Inject`어노테이션이 붙은 메소드를 `@Inject`어노테이션이 붙지 않은 메소드가 override하면, 주입은 아예 일어나지 않는다. 또 `@Inject`를 하는 메소드가 여러개 일 경우에는 어느 메소드 부터 주입이 일어날지 알 수 없으므로 의도치 않은 버그가 생길 수도 있다. 어쨌든, 생성자 주입이 가장 권장된다는 것만 기억하면 되겠다.

### 4. 의존성을 가진 의존성의 주입
만약 주입되는 인스턴스가 또 다른 의존성을 주입받고 있는 경우에는 해당 주입이 먼저 일어나고 나서야 주입이 실행된다. 

```java
Class A {
    @Inject B b;
}

Class B {
    @Inject C c;
}
```

가령 위와 같은 상황에서 B 인스턴스를 사용하기 위해서 C 라는 의존성이 먼저 주입되어 완성된 B가 주입이 된다는 의미이다. 이 모든 관리는 역시 DI Framework가 알아서 다 해준다. 정말 편리하다.

그렇다면 다음과 같은 경우에는 어떨까?

```java
Class A {
    @Inject B b;
}

Class B {
    @Inject A a;
}
```

이럴 경우에는 전통적인 방법으로 설계된 인젝터가 동작할 때 무한 루프를 돌기 때문에 빌드 타임에서 에러를 내어 준다. 그러나 이것도 가능하게 해줄 수 있는 2가지 방법이 있는데, 둘 중 한 곳에서 `Provider`의 `get()`을 호출해버리던가, `@Scope`(e.g. Singleton) 를 쓰는 방식이 그것이다. 하지만 위에서 `Provider`, `@Scope`를 자세히 설명 안하기도 했고, 본인도 잘 모르기 때문에 자세한 내용은 다음 포스팅으로 넘기겠다.

## Epilogue
---
DI Framework를 사용하면 편하다. 하지만 뭐든지 잘 알지도 못하면서 사용하게 되면 나중에 기가 막힌 버그를 맞닥뜨릴 확률이 높아지기 때문에 이미 문제 없이 잘 쓰고 있다고 하더라도 원리를 잘 파악하고 사용하는 게 중요해 보인다. 오늘 포스팅 내용을 요약하자면 의존성들은 이미 외부에서 준비되어 있으니 걱정말고, 되도록이면 생성자 주입을 통해 코딩을 하자는 것이다. 다음 포스팅에서는 Dagger2를 기준으로 DI Framework에 대해서 간단히 재조명하고, 직접 프레임워크를 적용한 프로젝트를 만들어 보겠다. 
