---
layout: post
title: 소풍 문제 (PICNIC, 난이도 하)
category: [online-judge]
author: hyungsun
image:
---


## Prologue
---
학교에서 알고리즘을 배울 때는 그 중요성에 대해 실감하지 못했다. 그것은 다음 두 가지 이유에서다.
- 실무에서는 이 정도까지 깊이 알아야 할 일이 별로 없을 것이다. 레드 블랙 트리가 웬 말.
- 구글링하면 다 나온다. 퀵 소트, 머지 소트가 뭔지만 알고 있으면 되지 않나?

나는 스스로 필요하다고 느끼지 않으면 절대 나의 자원을 투자하지 않기 때문에, 실제로 학교에서 이론적으로 배운 것 외에는 알고리즘을 제대로 공부한 적이 없다. 그러나 회사를 다니고 일을 하게 되면서, 다음과 같은 이유에서 알고리즘을 제대로 공부해 봐야겠다는 생각을 했다.

- 내 생각을 코드로 표현하고 싶다.

사실 언제든지 나의 모든 생각을 코드로 승화시킬 수 있었다면 나는 알고리즘을 공부할 필요성을 여전히 느끼지 못했을 것이다. 하지만 불행히도 일을 하면서 자신있다고 여겼던 컴퓨터적인 사고와 내 생각을 구현해 내는 능력에 의문을 품지 않을 수 없게 되었다. 슬픈 마음에 어떻게 하면 이 능력들을 기를 수 있을 까 고민하다, 결국 돌고 돌아 알고리즘으로 돌아온 것이다. 미련한 행보 끝에 다다른 결심인 만큼 더 열심히 해야겠다는 생각이다.

## Monologue
---

### 1. 문제
소풍문제는 다음과 같다.

> 안드로메다 유치원 익스프레스반에서는 다음 주에 율동공원으로 소풍을 갑니다. 원석 선생님은 소풍 때 학생들을 두 명씩 짝을 지어 행동하게 하려고 합니다. 그런데 서로 친구가 아닌 학생들끼리 짝을 지어 주면 서로 싸우거나 같이 돌아다니지 않기 때문에, 항상 서로 친구인 학생들끼리만 짝을 지어 줘야 합니다.
>
> 각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝지어줄 수 있는 방법의 수를 계산하는 프로그램을 작성하세요. 짝이 되는 학생들이 일부만 다르더라도 다른 방법이라고 봅니다. 예를 들어 다음 두 가지 방법은 서로 다른 방법입니다.
>
> - (태연,제시카) (써니,티파니) (효연,유리)
> - (태연,제시카) (써니,유리) (효연,티파니)

소녀시대라니, 언제적 ...

아무튼, 문제를 읽고나서 이해가 되지 않는 부분이 하나 있었다. 이 부분 때문에 부끄럽게도 30분 정도를 고민하다 날려먹었다. 매칭을 다 시켜놨는데 남는 녀석들끼리 친구가 아니라면? 즉, 주어진 친구 쌍이 모두를 매칭하기에 부족하다면 어떡하나라는 의문점이었다. 그렇지만 역시 문제는 제대로 읽어야 한다. 안그래도 종만 아저씨도 문제 똑바로 읽으라고 앞 장에 길게 써놓았다. 문제에서는 **항상 서로 친구인 학생들끼리만 짝을 지어 줘야**한다고 했다. 즉 앞서 말한 경우는 문제에서 찾고자 하는 경우가 아닌 것으로 치부해 버리면 그만이다.

### 2. 문제 풀이
프로그래밍 언어는 그때 그때 내가 쓰고 싶은 언어를 쓰기로 마음 먹었다. 그런데 파이썬같은 알고리즘 치트급 언어를 쓰기에는 양심에 찔려서, 웬만하면 인터프리트 언어는 피하려고 한다. 이번에는 C++로 구현해 보았다. 중요하지 않은 코드는 생략했는데, 생략없는 코드는 [여기에](https://github.com/poqw/JongmanBookSolutions/blob/master/poqw/picnic.cpp) 올려 두었다.

```cpp
list<pair<int, int>> friendPairs;

bool areFriends(int i, int j) {
  for (pair<int, int> pair : friendPairs) {
    if (pair.first == i || pair.second == i) {
      int another = pair.first == i ? pair.second : pair.first;
      if (j == another) {
        return true;
      }
    }
  }

  return false;
}

list<int> makeNewListWithoutPair(pair<int, int> pair, list<int> students) {
  list<int> newList;
  for (int student: students) {
    if (pair.first != student && pair.second != student) {
      newList.emplace_back(student);
    }
  }
  return newList;
}

int findNumberOfCases(list<int> students) {
  if (students.empty()) {
    return 1;
  }

  int count = 0;
  int target = students.front();
  for (int student : students) {
    if (areFriends(target, student)) {
      list<int> newList =
        makeNewListWithoutPair(make_pair(target, student), students);
      count += findNumberOfCases(newList);
    }
  }

  return count;
}
```
### 풀이

나는 java나 kotlin을 주로 쓰는데, C++의 `list`에 `copy()`가 없다고는 생각지도 못했다. 그래서 `makeNewListWithoutPair`라는 함수를 만들었는데, 그리 예쁘다고 생각하지는 않는다. 어쨌든, 풀이의 핵심은 `findNumberOfCases`라는 함수에 들어있다. 만약 0, 1, 2, 3, 4, 5의 학생 중에 (0, 1) 라는 짝을 찾았을 때 2, 3, 4, 5 끼리 어떻게 매칭이 되기만 하면 경우의 수를 하나 찾았다고 말할 수 있게 되므로 재귀를 쓸 수 있겠다는 생각이 들었다. 서로 친구인지 검사하는 함수도 `areFriends`로 간단히 만들어 두었다.

예제 중 하나를 내 코드로 돌려보자.

- 학생 : 0, 1, 2, 3, 4, 5
- 친구 : (0, 1), (0, 2), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4), (3, 5), (4, 5)

0, 1 짝을 찾은 후, 2, 3, 4, 5 를 넘긴다.
- 2, 3 짝을 찾은 후, 4, 5 (찾음)
- 2, 4 짝을 찾은 후, 3, 5 (찾음)

0, 2 짝을 찾은 후, 1, 3, 4, 5 를 넘긴다.
- 1, 3 짝을 찾은 후, 4, 5 (찾음)
- 1, 4 짝을 찾은 후, 3, 5 (찾음)

이렇게 총 4개의 케이스를 찾게 된다.

짝을 찾은 경우 아예 리스트에서 삭제해버리기 때문에, (1, 2), (3, 4) 를 찾은 후에 (3, 4), (1, 2)를 다시 찾는 중복은 걱정하지 않아도 된다. (3, 4)를 찾은 이후에 (1, 2)가 아예 없어서 찾지 못하기 때문이다.


### 개선점
딱히 뚜렷한 개선점은 보이지 않는다. `friendPairs`가 `list`일 이유는 없다는 것일 뿐...? C++의 `list`는 사용해 보니 그냥 기본적인 Linked list에 불과 하다는 것을 알게 되었다. 그런데 `friendPairs`는 서로 연결시켜 놓아봤자 문맥상 의미가 없다. A와 B는 친구 사이라는 것이 중요하지, (A, B), (C, D)라는 묶음이 서로 관련되어 의미를 가지는 것은 아니기 때문이다. 따라서 List가 아니라 Map이라는 자료형이면 서로 친구인지 판단하기 위해 List를 순회하면서 찾는 것이 아닌, O(1)의 시간복잡도로 구해낼 수 있을 것이다. 하지만 이 경우 중복키 문제를 해결해야 하므로 오히려 더 복잡해 질 것 같아 그만두었다. 

...라고 생각하고 정답을 보니, 이차배열로 `bool areFriends[10][10]`처럼 선언해 두면 깔끔하게 해결할 수 있다. `if (areFriends[A][B]) {...}` 이런 식으로 말이다. 복잡하게 생각하면 코드도 그만큼 복잡해진다는 걸 다시금 상기하게 된다.


## Epilogue
---
짜놓고 보니 C++보다는 java 스럽게 짰다는 생각이 든다. 정답 역시 재귀를 이용해서 풀었지만, 나의 풀이와 가장 큰 차이점은 `bool taken[]`을 선언해 이미 매칭이 된 학생은 false를 넣어준 채로 다음 재귀에 흘렸다는 것이다. 이게 더 좋은 방법인지는 잘 모르겠다. `empty()`같은 걸 쓰지 못해서 for loop를 한 번 돌아야 하기 때문이다. C++ `list`의 `empty()`는 직접 코드 찾아 들어가보니 첫 번째 원소가 allocate되어 있지 않으면 true를 반환하는 식으로 되어 있으므로 O(1)의 시간복잡도로 배열이 비어있는지 검사할 수 있다.

어쨌든, 이렇게 난이도 점수 (하)인 소풍 문제는 해결하였다.
