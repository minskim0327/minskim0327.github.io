---
layout: post
title: 원주율 외우기 문제 (PI, 난이도 하)
category: [online-judge]
author: hyungsun
image:
---

## Prologue

------
종만북에 등장하는 난이도 (하)짜리 문제 중 5번째로 등장하는 PI 문제를 풀어보았다. 

## Monologue

------

### 1. 문제

문제는 다음과 같다.

> #### 문제
>
> 가끔 TV 에 보면 원주율을 몇만 자리까지 줄줄 외우는 신동들이 등장하곤 합니다. 이들이 이 수를 외우기 위해 사용하는 방법 중 하나로, 숫자를 몇 자리 이상 끊어 외우는 것이 있습니다. 이들은 숫자를 세 자리에서 다섯 자리까지로 끊어서 외우는데, 가능하면 55555 나 123 같이 외우기 쉬운 조각들이 많이 등장하는 방법을 택하곤 합니다.
>
> 이 때, 각 조각들의 난이도는 다음과 같이 정해집니다:
>
> 1. 모든 숫자가 같을 때 (예: 333, 5555) 난이도: 1
> 2. 숫자가 1씩 단조 증가하거나 단조 감소할 때 (예: 23456, 3210) 난이도: 2
> 3. 두 개의 숫자가 번갈아 가며 출현할 때 (예: 323, 54545) 난이도: 4
> 4. 숫자가 등차 수열을 이룰 때 (예: 147, 8642) 난이도: 5
> 5. 그 외의 경우 난이도: 10
>
> 원주율의 일부가 입력으로 주어질 때, 난이도의 합을 최소화하도록 숫자들을 3자리에서 5자리까지 끊어 읽고 싶습니다. 최소의 난이도를 계산하는 프로그램을 작성하세요.
>
> #### 입력
>
> 입력의 첫 줄에는 테스트 케이스의 수 C (<= 50) 가 주어집니다. 각 테스트 케이스는 8글자 이상 10000글자 이하의 숫자로 주어집니다.
>
> #### 출력
>
> 각 테스트 케이스마다 한 줄에 최소의 난이도를 출력합니다.

일단 문제를 해결하기 위한 아이디어는 생각하기 쉽다. 문제 자체에서 점화식을 거의 다 만들어주기 때문이다. 여기서 말한 점화식이란, 다음을 뜻한다.

```cpp
길이 n 짜리 수열 P의 최소 난이도를 D(n), 어떤 수열 seq의 난이도를 diff(seq) 라고 하자.

또, 
seqA: 수열 P의 맨 끝 3개를 뽑아낸 수열.
seqB: 수열 P의 맨 끝 4개를 뽑아낸 수열.
seqC: 수열 P의 맨 끝 5개를 뽑아낸 수열.
이라고 하자.
    
D(n) = min(D(n-3) + diff(seqA), D(n-4) + diff(seqB), D(n-5) + diff(seqC))
```

암기를 위해 끊을 수 있는 단위가 3, 4, 5로 제한되는 것이 아주 큰 힌트이다. 아이디어가 거의 슈도코드급이기 때문에 그냥 편한 마음으로 구현하면 된다.

### 2. 아이디어 구현
아래 코드는 핵심적인 부분만 따온 것이고, 전체 소스 코드는 [여기에](https://github.com/poqw/JongmanBookSolutions/blob/master/poqw/pi.cpp) 올려 두었다.
```cpp
int cache[10001] = {-1};
int INFINITY = 987654321;

int calculateDifficulty(vector<int> seq) {
  if (seq.size() < 3 || seq.size() > 5) {
    throw runtime_error("Invalid sequence.");
  }

  int firstElem = seq.front();

  // Difficulty: 1, Case all elements are the same. e.g. 1111
  bool firstCase = true;
  for (int elem : seq) {
    if (elem != firstElem) {
      firstCase = false;
      break;
    }
  }

  if (firstCase) {
    return 1;
  }

  // Difficulty: 2, Case the element increases or decreases by one. e.g. 1234
  bool secondCaseInc = true;
  bool secondCaseDec = true;
  int increaseFlag, decreaseFlag;
  increaseFlag = decreaseFlag = firstElem;
  for (int elem : seq) {
    if (elem != increaseFlag) {
      secondCaseInc = false;
    }
    if (elem != decreaseFlag) {
      secondCaseDec = false;
    }
    increaseFlag++;
    decreaseFlag--;
  }

  if (secondCaseInc || secondCaseDec) {
    return 2;
  }

  // Difficulty: 4, Case two numbers alternate. e.g. 3535
  bool thirdCase = true;
  int secondElem;
  for (int i = 1; i < seq.size(); i++) {
    int elem = seq[i];
    if (i == 1) {
      secondElem = elem;
      continue;
    }

    if (i % 2 == 0 && elem != firstElem) {
      thirdCase = false;
      break;
    }

    if (i % 2 == 1 && elem != secondElem) {
      thirdCase = false;
      break;
    }
  }

  if (thirdCase) {
    return 4;
  }

  // Difficulty: 5, Case elements are an arithmetic sequence. e.g. 1357
  bool fourthCase = true;
  int diff = secondElem - firstElem;
  int flag = secondElem + diff;
  for (int i = 2; i < seq.size(); i++) {
    if (seq[i] != flag) {
      fourthCase = false;
      break;
    }

    flag += diff;
  }

  if (fourthCase) {
    return 5;
  }

  // Difficulty: 10, If not applicable to all of the above cases. e.g. 1434
  return 10;
}

int min(int a, int b, int c) {
  return min(min(a, b), c);
}

int dp(vector<int> seq) {
  cache[0] = 0;

  // The sequence by the lengths of 1 and 2 cannot be counted.
  cache[1] = cache[2] = INFINITY;
  cache[3] = calculateDifficulty({seq[0], seq[1], seq[2]});
  cache[4] = calculateDifficulty({seq[0], seq[1], seq[2], seq[3]});
  cache[5] = calculateDifficulty({seq[0], seq[1], seq[2], seq[3], seq[4]});

  for (int i = 5; i < seq.size(); i++) {
    vector<int> threeSeq = {seq[i - 2], seq[i - 1], seq[i]};
    vector<int> fourSeq = {seq[i - 3], seq[i - 2], seq[i - 1], seq[i]};
    vector<int> fiveSeq =
      {seq[i - 4], seq[i - 3], seq[i - 2], seq[i - 1], seq[i]};
    int threeDiff = cache[i - 3] + calculateDifficulty(threeSeq);
    int fourDiff = cache[i - 4] + calculateDifficulty(fourSeq);
    int fiveDiff = cache[i - 5] + calculateDifficulty(fiveSeq);
    cache[i + 1] = min(threeDiff, fourDiff, fiveDiff);
  }

  return cache[seq.size()];
}
```

### 3. 풀이

이전까지 종만북 (하) 난이도 문제를 푸는데에 너무 익숙해져 있다보니, 맨 처음에는 재귀를 이용한 완전탐색으로 풀어버렸다. 하지만 코드가 심하게 복잡했고, 아차 싶어서 DP로 전환해서 풀어보니 위에 보이는 `dp()`처럼 코드가 간결해졌다. 조심해야 하는 부분이라면, 암기를 위해 끊을 수 있는 간격이 3~5 사이의 숫자이기 때문에, 막 끊어서 계산하다가 남는 원소의 개수가 1 또는 2 라면 끊을 수 없는 경우인 것으로 처리를 해야 한다는 것이다. 이는 코드에서 남는 원소의 개수가 1 혹은 2일 때 양의 무한대를 리턴하게 해 `min()`함수에서 걸러지도록 했다.

캐시의 사이즈가 10,000이 아니라 10,001인 이유는 길이가 0인 수열의 난이도를 저장하기 위해서다. 원래는 아무 생각없이 10,000으로 사이즈를 정했었는데, 수열의 사이즈가 1, 2 인 경우에는 무한대를 리턴해야 하는 것과는 별개로, 수열 사이즈가 0인 경우에는 0을 리턴해 주어야 한다.

양의 무한대를 987,654,321으로 정한 이유는, 어떤 수이든 10,000 짜리 수열의 최대 난이도보다 크면 그만이기 때문이다. 10,000짜리 수열의 최대 난이도는 10,000 * 10 / 3 으로 기껏해야 35,000을 넘지 못한다.

한 가지 더, 벡터도 그렇고 리스트도 그렇고 C++의 자료구조는 익숙해질래야 익숙해지질 않는 것 같다. Kotlin처럼 사기급 언어만 써서 그런지 몰라도, 사용하기가 너무 불편하다. C언어 계열 언어들은 왜 이렇게 친해지기가 힘든걸까....

### 개선점

원래는 `dp()` 함수 안에 for문에서 size가 5 이하인 경우를 모두 처리하였다. 하지만 그렇게 하게 되면 10000개 짜리 인풋을 받는 동안 매번 사이즈가 5이하인 경우를 검사하는 오버헤드가 있기 때문에, 아래처럼 밖으로 빼버렸다.

```cpp
cache[0] = 0;

// The sequence by the lengths of 1 and 2 cannot be counted.
cache[1] = cache[2] = INFINITY;
cache[3] = calculateDifficulty({seq[0], seq[1], seq[2]});
cache[4] = calculateDifficulty({seq[0], seq[1], seq[2], seq[3]});
cache[5] = calculateDifficulty({seq[0], seq[1], seq[2], seq[3], seq[4]});
```
성능상으로 조금 더 이득이 있었을 뿐더러, 코드도 훨씬 더 보기 좋아졌다.


## Epilogue

------

이번 문제는 딱 보기에 쉬워보였고, 풀기에도 쉬웠다. DP 기본 문제 같은 느낌이다. 