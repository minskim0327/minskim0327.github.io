---
layout: post
title: 합친 LIS 문제 (JLIS, 난이도 하)
category: [online-judge]
author: hyungsun
image:
---

## Prologue

------
종만북에 등장하는 난이도 (하)짜리 문제 중 4번째로 등장하는 JLIS 문제를 풀어보았다. 체감상 난이도는 (하) 이상이었다.

## Monologue

------

### 1. 문제

문제는 다음과 같다.

> #### 문제
>
> 어떤 수열에서 0개 이상의 숫자를 지운 결과를 원 수열의 **부분 수열**이라고 부릅니다. 예를 들어 '4 7 6'은 '4 3 7 6 9'의 **부분 수열**입니다. 중복된 숫자가 없고 오름 차순으로 정렬되어 있는 **부분 수열**들을 가리켜 **증가 부분 수열**이라고 부르지요. 예를 들어 '3 6 9'는 앞의 수열의 **증가 부분 수열**입니다.
>
> 두 개의 정수 수열 A 와 B 에서 각각 **증가 부분 수열**을 얻은 뒤 이들을 크기 순서대로 합친 것을 **합친 증가 부분 수열**이라고 부르기로 합시다. 이 중 가장 긴 수열을 **합친 LIS**(JLIS, Joined Longest Increasing Subsequence)이라고 부릅시다. 예를 들어 '1 3 4 7 9' 은 '1 9 4' 와 '3 4 7' 의 **JLIS**입니다. '1 9' 와 '3 4 7' 을 합쳐 '1 3 4 7 9'를 얻을 수 있기 때문이지요.
>
> A 와 B 가 주어질 때, **JLIS**의 길이를 계산하는 프로그램을 작성하세요.
>
> #### 입력
>
> 입력의 첫 줄에는 테스트 케이스의 수 c ( 1 <= c <= 50 ) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 A 와 B 의 길이 n 과 m 이 주어집니다 (1 <= n,m <= 100). 다음 줄에는 n 개의 정수로 A 의 원소들이, 그 다음 줄에는 m 개의 정수로 B 의 원소들이 주어집니다. 모든 원소들은 32비트 부호 있는 정수에 저장할 수 있습니다.
>
> #### 출력
>
> 각 테스트 케이스마다 한 줄에, JLIS 의 길이를 출력합니다.

가장 먼저 들었던 아이디어는 '정수 수열 A와 B의 LIS를 각각 구해 합치는 경우로 문제를 풀 수 있을까?' 라는 것이었다. 하지만 이 아이디어는 다음과 같은 반례에 의해 간단히 막힌다. 나중에 풀이를 보니 대다수의 사람들은 처음 문제를 접하면 이 방식부터 생각한다고 한다. 뭔가 예측당한 느낌이라 언짢았다.

```cpp
A: 1 100 2 3
B: 1 2 3

A의 LIS: 1 2 3
B의 LIS: 1 2 3

아이디어에 의하면: 1 2 3 이므로 길이는 3
실제 답: 1 2 3 100 이므로 길이는 4
```

두 번째 아이디어는 '정수 수열 A와 B를 중복 제거로 합친 수열의 LIS로 문제를 풀 수 있을까?' 라는 것이었다. 하지만 이 아이디어 역시 반례는 쉽게 찾을 수 있다.

```cpp
A: 100 2 3
B: 1 3 2

합친 수열: 1 2 3 100
합친 수열의 LIS: 1 2 3 100 이므로 길이는 4

실제 답: 1 3 100 혹은 1 2 3 이므로 길이는 3
```

그러나 이 반례는 A와 B간에 공통원소가 있을 때만 발생한다. 만약 A와 B간에 서로 중복이 없다면, 답은 그냥 A와 B의 LIS 사이즈의 합이 된다. 고맙게도 합칠 때는 서로 마음껏 적절히 끼워넣을 수 있기 때문이다.

```cpp
A: 1 5 9 4 2
B: 7 6 3 8

A의 LIS: 1 5 9
B의 LIS: 3 8 혹은 6 8

아이디어에 의하면: 5
실제 답: 5
```

즉, A와 B가 길이가 각각 100만개가 되더라도 서로 중복이 없다면 LIS를 적절히 섞는 것만으로 답이 구해진다. 

그러면 첫 번째와 두 번째 아이디어를 섞어서, 다음과 같이 생각해 볼 수 있지 않을까.


1. B의 요소와 중복되는 원소들을 A에서 모두 제거한 뒤, LIS를 합친다. 이 때의 JLIS 길이를 a 라 하자.

2. A의 요소와 중복되는 원소들을 B에서 모두 제거한 뒤, LIS를 합친다. 이 때의 JLIS 길이를 b 라 하자.

3. 구해낸 JLIS중 사이즈가 max(a, b)인 JLIS를 답으로 취한다.


이 가설을 검증하기 위해서 반례를 열심히 찾아보다가, 내가 생각하는 모든 케이스를 커버한다는 걸 깨달았다. 중복을 제거하는 과정때문에라도 놓치는 답이 반드시 존재할 것이라고 생각했는데 그렇지 않았다. 그래서 꺼림칙하지만 일단은 구현해보기로 했다. 좀 더 고뇌하면서 수학적으로 증명하고 싶지만 통탄스럽게도 나에겐 주어진 시간이 별로 없다....

### 2. 아이디어 구현
아래 코드는 핵심적인 부분만 따온 것이고, 주석을 포함한 전체 소스 코드는 [여기에](https://github.com/poqw/JongmanBookSolutions/blob/master/poqw/jlis.cpp) 올려 두었다.
```cpp
int getLisSize(vector<int> seq, int maxValue) {
  if (seq.empty()) {
    return 0;
  }

  int first = seq.front();
  seq.erase(seq.begin());
  if (first > maxValue) {
    return getLisSize(seq, first) + 1;
  }

  return getLisSize(seq, maxValue);
}

int getLisSize(vector<int> seq) {
  return getLisSize(seq, NEGATIVE_INFINITY);
}

int getJlisSize(vector<int> seqA, vector<int> seqB) {
  vector<int> A = seqA;
  vector<int> B = seqB;
  for (auto it = A.begin(); it != A.end();) {
    bool isDuplicated = false;
    for (int value : seqB) {
      if (*it == value) {
        isDuplicated = true;
        it = A.erase(it);
        break;
      }
    }
    if (!isDuplicated) {
      it++;
    }
  }

  for (auto it = B.begin(); it != B.end();) {
    bool isDuplicated = false;
    for (int value : seqA) {
      if (*it == value) {
        isDuplicated = true;
        B.erase(it);
        break;
      }
    }
    if (!isDuplicated) {
      it++;
    }
  }

  return max(getLisSize(seqA) + getLisSize(B),
             getLisSize(A) + getLisSize(seqB));
}
```

### 3. 풀이

벡터라는 자료형에서 중복을 제거하는 게 생각보다 까다로웠다. 그리고 역시 신기하게도, 내가 생각할 수 있는 모든 케이스는 이 코드로 커버가 가능했다. 종만북에 나오는 풀이와 완전히 다른데, 답이 될 수 있는지는 잘 모르겠다.

앞서 아이디어에서 이야기 한 1, 2, 3단계를 구현한 함수가 바로 `getJlisSize`이다. 다만 중복을 제거하는 부분이 저렇게 불필요하게 길어진 이유는, `vector`가 내가 생각하는 것과는 다르게 동작했기 때문이다. 이번 기회에 좀 더 자세히 알 게 된 것 같다. 중복을 제거하는 부분에서 내가 동작하겠거니 하고 생각하고 짰던 코드는 다음과 같다.

```cpp
for (auto it = A.begin(); it != A.end(); ++it) {
  for (int value : seqB) {
    if (*it == value) {
      it = A.erase(it);
      break;
    }
  }
}
```

하지만 이렇게 해서 컴파일을 돌리면 아무 에러도 뱉지 않고 프로그램이 끝나 버린다. 물론 실행도 되지 않고다. 그 이유는  바로 `erase`라는 함수 때문이었다.

`vector`는 `erase`를 하게되면 `iterator`를 한 칸 뒤로 옮겨버린다. 하지만 `erase`라는 함수가 원소를 지우는 것만 하겠어! 라는 본질을 잊어버리고 제멋대로 side effect를 낸 것이 아니다. `vector`는 기본적으로 순서를 갖는 시퀀스 컨테이너인데, 중간에 값을 삭제하게 될 경우 뒤에 있는 값들을 끌어다가 원래 모양을 다시 갖추어야 한다. 그래서 결국 원하는 대로 동작하도록 만들기 위해, 구리지만 다음과 같이 바꾼 것이다.

```cpp
for (auto it = A.begin(); it != A.end();) {
  bool isDuplicated = false;
  for (int value : seqB) {
    if (*it == value) {
      isDuplicated = true;
      it = A.erase(it);
      break;
    }
  }
  if (!isDuplicated) {
    it++;
  }
}
```



### 개선점

일단 중복을 제거하는 부분에서부터 시간복잡도는 n의 제곱을 간단하게 달성해버린다. 이 부분을 개선하기 위해서는 종만북의 풀이에 나와있는 대로 DP를 써야 한다. 종만북의 풀이는 조금 불친절하게도 main함수가 나와있지 않다. 책의 길이를 줄이려는 마음은 잘 알겠는데, 앞에 음의 무한을 A, B에 각각 집어넣기 때문에 함수가 항상 답보다 2만큼 큰 수를 뱉는다는 건 작게라도 써줘야지. 시간이 별로 없을 때 남의 코드를 디버깅하는 것보다 나를 지치게 하는 일은 없다.

아래는 main 을 포함한 종만북 풀이이다.

```cpp
#include <iostream>
#include <list>

using namespace std;

const long long NEGINF = numeric_limits<long long>::min();
int n, m, A[100], B[100];
int cache[101][101];

int jlis(int indexA, int indexB) {
  int ret = cache[indexA + 1][indexB + 1];
  if(ret != -1) return ret;

  ret = 2;
  long long a = (indexA == -1 ? NEGINF : A[indexA]);
  long long b = (indexB == -1 ? NEGINF : B[indexB]);
  long long maxElement = max(a, b);

  for(int nextA = indexA + 1; nextA < n; ++nextA) {
    if (maxElement < A[nextA]) {
      ret = max(ret, jlis(nextA, indexB) + 1);
    }
  }

  for(int nextB = indexB + 1; nextB < m; ++nextB) {
    if (maxElement < B[nextB]) {
      ret = max(ret, jlis(indexA, nextB) + 1);
    }
  }
  return ret;
}

int main() {
  list<int> answers;
  int testCaseCount;
  cin >> testCaseCount;
  while (testCaseCount-- > 0) {
    cin >> n >> m;
    memset(cache, -1, sizeof(int) * 101 * 101);

    for (int i=0; i < n; i++) {
      cin >> A[i];
    }
    for (int i=0; i < m; i++) {
      cin >> B[i];
    }
    answers.push_front(jlis(-1, -1) - 2);
  }

  for (int answer: answers) {
    cout << answer << endl;
  }
}
```

풀이에 나온대로 점화식을 착실하게 구현했다는 것은 알겠다. 문제는 그 점화식을 어떻게 도출해 냈느냐다. 책에서는 이렇게 생각해 볼 수 있지 않을까? 라는 식으로 순진하게 풀이에 발을 들이는데, '나처럼 번득이는 직관이 아니면 풀지 못합니다'와 완전히 같은 뜻이 아닌가 싶다. 경험을 더 쌓아야 하는 건가? 어쨌든 다음 회고때는 이 문제를 DP로 풀 수 있었으면 좋겠다.

## Epilogue

------

쿼드트리 문제를 풀때와는 반대로, 문제만 보고는 쉬울 것이라 생각했는데 풀고보니 어려웠다. 할 일도 많은데 시간을 많이 할애해야 했어서 스트래스를 많이 받았다. DP에 대해서 능숙해진 것도 아니고, 풀이도 맘에 들진 않는다. 어쨌든, 시간이 별로 없으니 마무리 하도록 하겠다.