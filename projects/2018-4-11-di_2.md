---
layout: post
title: DI 두 번째, Dependency Injection Dagger2로 시작하기
category: [dependency-injection, dagger2]
author: hyungsun
image:
---


## Index
---
- [DI 첫 번째, Dependency Injection에 관하여]({{site.url}}/di_1)
- [DI 두 번째, Dependency Injection Dagger2로 시작하기]({{site.url}}/di_2)

## Prologue
---
[DI 첫 번째 이야기]({{site.url}}/di_1) 포스팅을 한 후 여러가지 일로 바빠서 신경을 못 쓰고 있었다. 그런 내게 프로그래밍을 거의 처음 접하는 사람이 질문을 던졌다.
> "Dagger2 어떻게 쓰는 거에요?"

기본적인 개념에 대해 포스팅까지 했을 정도니 설명 정도는 할 수 있겠다 싶어 자신있게 대화를 시작했는데, 이야기를 할수록 점점 말문이 막혔다. 거기서 느꼈다 - 아... 난 아직도 잘 모르고 있구나.

그 동안 열심히 살고 있다고 생각했었으나 오늘 겪어버린 왠지 모를 패배감에, 퇴근 후에 밤을 새는 한이 있더라도 [Dagger2](https://github.com/google/dagger)를 직접 써보기로 했다. 지난 번에 만든 [RxJava Toy 프로젝트](https://github.com/poqw/RxJavaToy)에 Dagger2를 적용하는 것부터가 바로 그 시작이다.

## Monologue
---
### 1. 개념과 구조는 다르다.
개념만을 알고 있다고 해서 구조를 짤 수 있는 것은 아니다. 구조를 잘 짜려면 개념 뿐만이 아니라 경험까지 있어야 한다. 내가 제일 먼저 한 일은 이런 경험을 흉내내기 위해 인터넷에서 sample code를 찾아보는 것이었다. 다행히 [기본적인 예제](https://github.com/android10/Android-CleanArchitecture)를 금방 찾을 수가 있었다(안드로이드 프로젝트가 아니라). 이런 best practice를 찾아 분석하다 보면 내가 무엇을 모르는지 쉽게 알 수 있다. 물론 그렇게 찾은 모르는 것들이 알고 있는 것들로 되는 건 쉬운 일이 아니지만 말이다.

### 2. 어느 부분에 의존성이 있는가
Dagger2가 아무리 편리하다고 한들, 사실은 멍청한 녀석이라 내가 짠 코드의 어떤 부분들이 의존성을 가지는지 설명해 놓은 지도를 그려줘야 한다. 우선은 지도를 그리기 위해선 어떤 부분이 의존하는 지를 잘 알고 있어야 한다. 기존에 [내가 짰던 코드](https://github.com/poqw/RxJavaToy)에는 다음과 같은 의존성이 있었다. 

`MainActivity.java`
```java
@Override
protected void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
  adapter = new RepoItemAdapter(new ArrayList<>());
  binding.recyclerView.setAdapter(adapter);

  github = new GithubClient();	// 의존성이 있는 부분.
  disposable = github.getApi().getRepos(OWNER)
      .subscribeOn(Schedulers.io())
      .observeOn(AndroidSchedulers.mainThread())
      .subscribe( items -> adapter.updateItems(items));
}
```
[예전 포스팅]({{site.url}}/di_1)에서 `new` 키워드는 의존성을 만들어 내는 주범이라 했다. 그렇다면 위에서 `github = new GithubClient();`는 의존성인 반면, `adapter = new RepoItemAdapter(new ArrayList<>());`는 의존성이 아닌 이유는 무엇일까?

사실 의존성이 있는 게 맞다. 그렇지만 의존성이 있다고 주석을 달지 않은 이유는 너무도 확실하게 `MainActivity`에서만 쓰일 녀석이라 굳이 외부 컨테이너에서 의존성을 주입받지 않아도 되기 때문이다. `MainActivity`에 있는 Recycler View를 위해 만들어 둔 녀석을 다른 엑티비티가 쓸 리가 없는 것이다. 즉, 다른 곳에서도 쓰일 가능성이 농후한 `GithubClient`만 Dependency Injection을 해주면 된다.

### 3. 의존성 지도 그리기
의존성이 있는 부분을 찾았으니, 지도를 그릴 차례다. 지도는 `@Module`, `@Provides` 어노테이션을 통해 그릴 수 있다.
각각은 다음의 의미를 지닌다.
- `@Module`: `@Provides` 묶음으로 이루어진 클래스위에 적어야 하는 어노테이션.
- `@Provides`: 직접적으로 객체를 생산해 주는 메소드 위에 적어야 하는 어노테이션.

결국 객체의 생성은 내가 직접하는 것이고, 그걸 꼬이지 않게 연결시켜주는 작업을 DI Framework가 해주는 것이다. 아래와 같이 `new` 키워드를 써서 말이다.

`GithubModule.java`
```java
@Module
public class GithubModule {
  @Singleton
  @Provides
  public GithubClient provideGithubClient() {
    return new GithubClient();
  }
}
```
위에서 `@Singleton`은 의존성 Scope와 관련된 녀석인데, 이 의존성이 유효한 범위 내에서 항상 싱글톤 인스턴스임을 보장한다는 뜻이다. 

Module은 사실 여러 개가 될 수 있다. 위에 예제로 올려놓은 Dagger2 best practice를 잠깐 살펴보자. 조금 복잡해 보이지만, `ActivityModule`, `AppModule`은 Dagger를 사용하는 Android 프로젝트에서 거의 필수적으로 등장한다. `AppModule`은 Application 자체가 유효한 범위 내에서 사용할 모듈이고, `ActivityModule`는 Activity가 유효한 범위 내에서 사용할 모듈이다. 그러니, App의 라이프 사이클 전반에 걸쳐서 사용할 객체는 `AppModule`에서, 각종 Activity들은 `ActivityModule`에서 Provides 해주면 될 것 같다. 대세를 따르기 위해 나도 만들어 보았다.

`AppModule.java`
```java
@Module
public class AppModule {

  private final Dagger2ToyApp app;
  
  public AppModule(Dagger2ToyApp app) {
    this.app = app;
  }

  @Singleton
  @Provides
  public Context provideContext() {
    return this.app;
  }
}
```
`Dagger2ToyApp`은 아래에서 설명할 것이다. 여기서는 `Context`를 Provides를 했다는 것에 주목하자. 코드 전반에 걸쳐서 쓰진 않았지만 말이다. 나중에 resources를 접근할 일이 있거나, intent를 다루거나, inflate가 필요할 때 요긴하게 쓰일 것이지만, 아직 지금 규모의 프로젝트에선 쓰이지 않았다.

`ActivityModule.java`
```java
@Module
abstract class ActivityModule {

  @ActivityScope
  @ContributesAndroidInjector
  abstract public MainActivity contributeMainActivityInjector();
}
```
`@ContributesAndroidInjector`는 추상 클래스에서 Provides를 해주기 위해서 사용된다. `new MainActivity()`같은 걸 했다간 앱의 라이프사이클이 꼬일 수도 있기 때문에, 이런 특수한 추상 Injector를 쓰는 것으로 생각된다.

`ActivityScope.java`
```java
@Scope
public @interface ActivityScope {}
```
`@ActivityScope`는 내가 직접 만들어낸 어노테이션이다. 이 어노테이션이 달릴 인스턴스가 유효한 Scope를 ActivityScope로 지정하기 위해 사용했다.

`Dagger2ToyApp.java`
```java
public class Dagger2ToyApp extends Application implements HasActivityInjector {

  @Inject
  DispatchingAndroidInjector<Activity> activityInjector;

  @Override
  public void onCreate() {
    super.onCreate();
    DaggerAppComponent.builder()
        .appModule(new AppModule(this))
        .build().inject(this);
  }

  @Override
  public DispatchingAndroidInjector<Activity> activityInjector() {
    return activityInjector;
  }
}
```
`Dagger2ToyApp.java`는 `Application`를 상속받아, 이 앱 자체를 정의하는 클래스이다. 주의할 점은 `DaggerAppComponent`는 Dagger2가 알아서 만들어 준다는 점이다. 여기서 `DispatchingAndroidInjector`는 엑티비티 인젝터이다. 

모듈들이 여러개 만들어졌으니, 이 녀석들을 한 데 묶어 놓는 녀석들이 필요하다. 지도 조각들을 잘 정돈해서 한 곳에 모아 준다라는 느낌인데 `@Component`가 이를 담당한다. 

```java
@Singleton
@Component(modules = {
    AppModule.class,
    ActivityModule.class,
    GithubModule.class
})
public interface AppComponent {
  void inject(Dagger2ToyApp app);
}
```
modules에 해당 컴포넌트가 어떤 모듈들을 담고 있는지를 명시해 주어야 한다. Dagger는 이 컴포넌트를 보고서 `DaggerAppComponent`를 생성하게 된다. 즉,     
```java
DaggerAppComponent.builder()
    .appModule(new AppModule(this))
    .build()	// AppComponent
```
여기까지가 의존성지도를 가진 `DaggerAppComponent`로부터 내가 만든 `AppComponent`를 만들어 내는 것이고, `.inject(this)`로 앱 의존성을 넣어주는 방식인 것이다. 약간 마무리 같은 느낌이랄까.

여기까지 하고 빌드를 하게 되면, 
`ActivityModule_ContributeMainActivityInjector`, `AppModule_ProvideContextFactory`, `GithubModule_ProvideGithubClientFactory`, `Dagger2ToyApp_MembersInjector`가 각각 생겨나게(generated) 된다. 내가 `@Provides`나 `@ContributesAndroidInjector`를 붙였던 메소드들이 클래스로 둔갑하는 것이다. 코드를 보면 이 녀석들이 서로 어떤 상호작용을 거쳐서 의존성을 생산해 내는지 알게 될 것이다. 물론 나는 Factory 패턴이나 Proxy패턴을 쓰는구나 정도 밖에는 알아차릴 수가 없었지만...

### 4. 의존성을 주입하려면
이제 지도를 전부 그린 후에 Dagger에게 넘겨주는 것까지 성공했다. Dagger로부터 이제 의존성을 넘겨 받으면 되는 일만 남았다.

이 부분은 엄청 간단하다.

```java
public class MainActivity extends BaseActivity {
  private static final String OWNER = "poqw";

  @Inject
  GithubClient github;	// 의존성을 주입했다!

  private RepoItemAdapter adapter;
  private Disposable disposable;

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ActivityMainBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_main);
    adapter = new RepoItemAdapter(new ArrayList<>());
    binding.recyclerView.setAdapter(adapter);
    disposable = github.getApi().getRepos(OWNER)
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe( items -> adapter.updateItems(items));
  }
  
  // ...
}
```
`@Inject` 라는 어노테이션을 사용해 이미 객체가 생성되었다고 생각하고 코딩해버리면 된다. 예전에 생성자 주입이 가장 권장된다고 적었었는데, Activity 같은 경우에는 어쩔 수 없이 멤버 인젝션을 해야 한다. 안드로이드 Activity에서는 생성자를 쓰지 않기 때문이다. 물론 할 수도 있겠지만 `onCreate()` 보다 먼저 실행되어 버리기 때문에 절대로 권장되지 않는다.

## Epilogue
---
사실, 이번 포스팅은 거의 느낌이나 넋두리에 가깝다. 본인조차도 코딩을 하면서 무척 많이 해멨기 때문에 이 글을 읽는 분들에게 제대로 전달되었을리 만무하다. 나중에 더 개념이 확실히 잡히게 되면 수정하는 것으로 하고, DI에 대한 내용은 여기서 마무리 하겠다.