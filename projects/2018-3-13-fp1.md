---
layout: post
title: Functional Programming
category: [functional-programming]
author: hyungsun
image:
---

최근 몇 년 들어서 세련된 코딩 트랜드로서 자리매김한 **함수형 프로그래밍(Functional Programming)**은 여러분의 생각보다는 오래된 이야기다. 무려 **50년 전**부터 소수의 개발자들이 연구해왔던 개념이라 한다면 쉽게 믿을 사람이 있을까? 

사실, 함수형 프로그래밍은 컴퓨터의 자원낭비를 최소화 하기 위해 고안된 프로그래밍 방식이다. 하지만 하드웨어는 우리 모두가 알다시피 눈부신 속도로 발전했다. 그래서 조금의 자원 낭비정도는 살짝 눈감아 줘도 사용자 경험이나 서비스 제공 면에 있어서 아무 이상이 없었고, 자연스레 대다수의 개발자는 함수형 프로그래밍을 외면하게 되었다. 그 동안은 소프트웨어적으로 최적화를 했을 때 얻는 투자 대비 효용보다, 새로 나온 하드웨어로 프로덕트를 갈아끼우는 게 훨씬 효율적이었다는 것이다.  하지만 2000년도 중반이 넘어가면서, 사람들은 슬슬 더 이상 예전과 같은 속도로 발전하지 못하는 하드웨어에 불안감을 느끼기 시작했다. 새로 나온 하드웨어로 갈아끼워도 이전과 비교해서 별반 다를 것이 없으니 결국 시장에서 소프트웨어를 최적화 시킨 쪽이 경쟁력을 가지도록 판도가 바뀐 것이다. 

또, 점점 소프트웨어의 덩치가 커지기 시작하면서 유지보수 측면에서 프로그래밍 언어 자체의 표현력이 이슈가 되기 시작했다. 복잡하게 엉켜있는 스파게티 코드는 유지보수하기가 너무 힘들다는 걸 사람들이 슬슬 깨달은 것이다. 함수형 프로그래밍은 거의 모든 것을 함수로 쪼개서 문제를 해결하는 데 초점을 두는데, 큰 문제를 해결하기 위한 코드보다 작은 문제를 해결하기 위한 코드가 더 간결할 수 밖에 없으므로 대개 함수형 프로그래밍으로 짜여진 코드는 간결하다. 즉 함수형 프로그래밍으로 짜여진 코드는 상대적으로 간결했고, 간결한 코드는 읽기 쉬우므로 곧 유지보수에 들이는 정신적인 노동을 줄여주었다. 이것이 바로 쉽게 친해지기 힘든 함수형 프로그래밍이 이제서야 재조명을 받게 된 이유다.

## 어떻게 자원을 효율적으로 사용하나
우리가 쓰는 컴퓨터는 대부분 [폰 노이만 아키텍쳐](https://ko.wikipedia.org/wiki/%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C_%EA%B5%AC%EC%A1%B0){:target="_blank"}를 따른다. 이는 멀티 코어 프로세스가 하나의 메모리를 공유하면서 병렬처리를 하도록 설계된 아키택쳐를 의미한다. 이 때 공유되는 메모리가 가변적(Mutable)이라면, 상당히 신경써야 할 점이 많아진다. 그도 그럴 게, 필요할 때 쓰려고 A라는 공간에 B를 넣어놨는데 쓰려고 보니 C로 바뀌어 있다면, 당황스럽지 않겠는가. 내가 사용하기 전까지 C가 침범하지 못하도록 부지런히 검사해야 할지도 모른다.

함수형 프로그래밍에서는 이를 원천봉쇄하는 방식을 택한다. 기본적으로 모든 자료형은 불변(Immutable)하다고 보는 것이다. 병렬 프로그래밍을 해본 사람들은 Immutable 한 List와 Mutable한 List를 sorting하는 것이 무슨 차이가 있을지 잠깐 생각해보자. 조그마한 List라면 별 차이 없을 지 모른다. 하지만 여러가지 클래스들이 얽혀있는 상황이라면 아무래도 Mutable한 쪽이 훨씬 어렵다. Immutable한 List라면 불변함이 보장되기 때문에 주변의 상황이 어떻게 되든 신경 안쓰고 쉽게 정렬할 수 있을 것이다. 

## 함수형 프로그래밍의 함수
자료형이 Immutable하다는 것이 감이 오는가? 잘은 모르겠지만, 그렇게도 코딩을 할 수 있을 것 같다는 느낌이 드신 분들도 있을지 모른다. 뭐 그런 느낌이 들지 않아도 상관은 없다. 함수형 프로그래밍은 느낌만으론 되지 않기 때문이다. 하지만 이 글에선 느낌만 잡는 것이 목적이기 때문에, 자세한 내용은 추후 다른 포스팅에서 다루도록 하겠다.

함수형 프로그래밍에서 함수는 사실 우리가 기존에 많이 사용하던 메소드보단 **수학에서의 함수 f(x)와 가깝다**.  
가령, 다음과 같이 로봇을 움직이는 코드가 있다고 하자.
```java
Robot robot = new Robot();
robot.moveLeft();
robot.moveRight();
robot.stop();
```
이 보다는 아래 쪽이 FP에 더 가깝다는 뜻이다.
```java
Robot robot = new Robot();
moveLeft(robot);
moveRight(robot);
stop(robot);
```
기존(윗 방식)의 OO(Object Oriented)에서는 객체에 집중했던 반면, 아래 방식은 함수 그 자체에 집중한 듯한 느낌이 든다. 즉 윗 방식은 메소드를 사용했고, 아래 방식은 함수를 사용했다는 것이다. 메소드와 함수의 가장 큰 차이점을 나타내는 예제이기도 한 것인데, 메소드는 객체에 종속적이서 객체의 상태가 달라지면 인풋이 같아도 아웃풋이 달라질 수 있는 반면 함수는 인풋이 같으면 아웃풋이 항상 같다. 함수형 프로그래밍에서는 부작용(side-effect)을 최대한 없애기 위해 메소드 보단 함수를 사용하는 방식을 지향한다.

만약 `robot`이 아니라 `human`을 움직여야 한다는 임무가 주어졌을 때, 어느 방식이 더 나을지를 생각해보자. 또, `moveUp(), moveDown()`을 추가해야 하는 경우에는 어떨까? 각 프로그래밍에는 장단점이 있다. 
전자인 경우, OO입장에서는 상위 추상 클래스를 만들어서 상속받고 추상 메소드를 구현해주고 등등... 을 해야겠지만, FP입장에서는 단지 moveLeft, moveRight만 수정해주면 된다. 또 후자인 경우에는 OO입장에서는 메소드 몇 개만 더 추가하면 되는 간단한 테스크이지만, FP입장에서는 OO와 비슷하거나 혹은 조금 더 많이 코드를 수정해야 될 것이다.

\* 원래는 더 많은 내용을 적으려고 했었으나 java 8이냐, 혹은 Kotlin이냐의 언어 결정적인 문제에서부터 개인적인 이해도가 글을 쓰기에 합당한 정도인지 확신이 서지 않으므로 글을 여기서 마치도록 하겠다.

