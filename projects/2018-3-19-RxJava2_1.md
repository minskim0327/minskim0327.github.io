---
layout: post
title: RxJava2 첫번째, RxJava에 관하여
category: [rxjava, reactive-programming]
author: hyungsun
image:
---


## Index
---
- RxJava2 첫번째, RxJava에 관하여
- [RxJava2 두번째, 간단한 프로젝트 생성해보기]({{site.url}}/RxJava2_2)
- [RxJava2 세 번째, Retrofit 적용하기]({{site.url}}/RxJava2_3)

## Prologue
---
진행 중인 프로젝트에 `rxjava`를 도입해야 해서 알아보기 위해 열심히 참고할 만한 웹사이트를 찾아 헤멨는데, 정말 자료를 찾아보기가 힘들었다. 결국 찾아낸 (다행히 한글로 된)[포스팅](http://pluu.github.io/blog/rx/2015/04/29/rxjava/){:target="_blank"}이 하나 있는데, 예제가 자세해서 입문자가 보기에 좋은 글 같았다. 
이 포스팅을 작성한 저자는, [`rxjava`](https://github.com/ReactiveX/RxJava){:target="_blank"}를 두 단어로 합쳐서 표현했다. "[StreamAPI](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html){:target="_blank"} + 비동기 콜백"이 바로 그것이다. 표현 자체가 `StreamApi`에 너무 집중한 듯한 느낌이 들긴 하지만(`filter` 나 `map` 같은 stream operator때문에 `StreamApi`라고 표현한 것일 텐데, `rxjava`에서 operator가 저 정도로 무게감이 있는 것 같지는 않다), 전체적인 맥락에서 틀린 말은 아니다. 어쨌든 저 포스팅은 2015년도에 작성되었고 지금은 Rxjava2가 나왔기 때문에 당시와는 몇 가지 [달라진 점](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0){:target="_blank"}이 있긴 하지만, 여전히 초보자 입장에서는 참고할 만 하다.

## Monologue
---
### 1. RxJava는 무엇?
`rxjava`의 `rx`는 Reactive Extention의 줄임말이다. 한글로 번역하면 '반응형 확장' 정도 될텐데 사실 이해하는 데 큰 도움은 되지 않지만 혹여 궁금해 할 사람이 있을까봐 이야기를 꺼냈다. 다만 `rxjava`를 이해하기에 있어서 `rx`라는 prefix의 의미보다는 `Reactive Programming`이라는 것을 이해하는 것이 훨씬 더 도움이 된다. 여기에 관해서는 [이 포스팅](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754){:target="_blank"}이 매우 자세하게 설명하고 있으므로 참고하기 바란다. 아주 간단히 읽어보긴 했는데, 그렇게 쉬운 내용은 아니다. 하지만 읽어보면 왜 `rxjava`를 써야 하는지, 어떤 상황에 써야 하는지에 대한 대략적인 감을 잡을 수 있다. 읽기 귀찮은 사람들을 위해 어떤 상황에 써야 하는지만 간단히 요약하자면 다음과 같다. 
- 마우스 움직임, 버튼 클릭과 같은 UI 이벤트
- 속성 변경, 컬렉션 업데이트, 주문 완료, 등록 승인 등의 도메인 이벤트
- 메시지 버스의 브로드캐스트처럼 대기 시간이 짧은 미들웨어의 푸시 이벤트

다시 말해, `rx`는 `Reactive`라는 단어에 알맞은 상황에 적용할 때 가장 valuable하다. 

### 2. RxJava와 Java8
RxJava는 Java8을 완벽하게 지원한다. 그런데 나는 바꿔 말하고 싶다. RxJava를 쓰려면 반드시 Java8을 알아야 한다. 그 이유는 똑같이 동작하는 다음 2개의 예제를 보면 이해할 수 있을 것이다.

java 6 version
```java
// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(new Func1<String, Observable<JsonDocument>>() {
        @Override
        public Observable<JsonDocument> call(String id) {
            return bucket.get(id);
        }
    }).subscribe(new Action1<JsonDocument>() {
        @Override
        public void call(JsonDocument document) {
            System.out.println("Got: " + document);
        }
    });
```
java 8 version
```java
// Loads 3 documents in parallel
Observable
    .just("doc1", "doc2", "doc3")
    .flatMap(bucket::get)
    .subscribe(document -> System.out.println("Got: " + document));
```
코드가 간결해야 버그가 숨어들지 못한다는 [비야네](https://en.wikipedia.org/wiki/Bjarne_Stroustrup){:target="_blank"}의 말을 되새기자. java8은 선택이 아닌 필수다.

### 3. `Observable` 이해하기
위 예제코드에서 등장하는 `Observable`은 상당히 중요하므로 반드시 이해를 하고 넘어가야 한다. 기본적으로 `rxjava`는 [옵저버 패턴](https://ko.wikipedia.org/wiki/%EC%98%B5%EC%84%9C%EB%B2%84_%ED%8C%A8%ED%84%B4){:target="_blank"}을 베이스로 하고 있다. 즉, 옵저버가 발행(emit)을 하면 어떠한 데이터의 흐름(stream)이 만들어지고 리시버가 구독(consume)하는 형태이다. 이 때 데이터를 발행하는 녀석은 관찰 대상자, 즉 `Observable`(슈뢰딩거의 고양이를 생각하자)이라는 녀석이고, 다음 3가지 행동을 할 수 있다.

1. `onNext` : 새로운 데이터를 전달한다.
2. `onCompleted` : 스트림의 종료.
3. `onError` : 에러 신호를 전달한다.

`rxjava`에서 데이터를 구독하는 녀석은 `Observer`(슈뢰딩거 본인을 생각하면 되겠다)라는 녀석이고, 데이터의 흐름(stream)속에서 데이터를 건져서 소비한다는 느낌으로 받아들이면 좋겠다. 즉 `Observer`가 `subscribe`를 시작하면 `onNext`의 반복으로 n개(n의 범위는 [0,inf))의 데이터를 받다가, `onCompleted`이나 `onError`를 만나면 한 stream이 일단락 되었다고 보면 된다. 이 때 받은 데이터를 가지고 UI에 표시를 하든 새로운 데이터를 만들어서 다시 서버에 전송을 하든 그건 이제 개발자의 자유다.

`Observable`을 더 이상 구독하고 있을 필요가 없다면, `unsubscribe`나 `dispose`를 해주어야 한다. `unsubscribe`는 구독을 중지하는 것이고 `dispose`는 아예 더 이상 구독을 하지 않도록 처분하는 것이다. 주의할 점은 만약 UI이벤트를 핸들링하기 위해 구독하고 있었다면 `dispose`는 안드로이드 기준에서 `onDestroy`처럼 정말로 구독할 필요가 없는 시점에 해야 한다는 것이다. 만약 아래 코드 처럼 사용하게 된다면 구독을 시작하자마자 처분해버리기 때문에 결과적으로 아무런 데이터도 발생되지 않는다.

```java
// onCreate()
manager.updateEvent()
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .subscribe(this::updateView)
        .dispose();
```

### 4. 왜 RxJava?

이것만 보고는 아직도 감이 잘 안올 수가 있다. 사실 `Rx`가 대단한 이유는 **시간축이 존재하는 일련의 이벤트들을 Immutable한 List처럼 핸들링할 수 있게 만들어준다**는 것에 있다. 자세한 내용은 [이 포스팅](https://medium.com/@andrestaltz/2-minute-introduction-to-rx-24c8ca793877){:target="_blank"}을 참고하자. 이것이 가능한 이유는 `subscribe`하는 시점이 오기 전까지 `Observable`은 아무런 데이터도 방출하지 않고 기다리기 때문(오해는 말자. 동기적으로 동작하도록 코딩할 수도 있다)이다. Immutable한 List로 변신했다면 stream operator로 자유롭게 가지고 놀면 되니, 개발자 입장에서는 신세계(?)라 할 수 있겠다.

## Epilogue
---
솔직히 터놓고 말해, 이 포스팅은 머리에 든 것 하나 없이 여기저기서 구글링 한 결과를 짜집기 한 것에 불과하다. 그 부분이 양심에 찔리기도 하고 스스로도 써먹을 줄 알아야 하기 때문에 다음 포스팅에서 `RxJava`로 간단한 프로젝트를 만들어서 올려볼 계획이다. 
어쨌든 요약하자면, **`RxJava`는 반응형(비동기적) 이벤트를 굉장히 유연하고 쉽게 핸들링 할 수 있도록 설계되었다는 것**이다. 핸들링을 어떻게 한다는 것인지에 관해 의문을 가진 사람은 [ReactiveX 공식 문서에서](http://reactivex.io/documentation/ko/operators.html){:target="_blank"} 그 방대한 쓰임새를 연구해 보기 바란다.
또, 개념에 대해 더 자세하게 알고 싶으신 분은 반드시 zerobrain의 [gitbook](https://www.gitbook.com/book/zerobrain/what-is-rxjava-in-korean/details){:target="_blank"}을 읽어보자. `Observerble`에 대한 설명 뿐만 아니라 `Subject`, `비동기 처리`에 관한 부분까지 설명되어 있다.

## Reference
---
[couchbase developer](https://developer.couchbase.com/documentation/server/3.x/developer/java-2.0/observables.html){:target="_blank"}
